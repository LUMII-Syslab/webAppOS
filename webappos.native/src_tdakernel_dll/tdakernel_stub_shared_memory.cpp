// Automatically generated by StubsGenerator.java

#include "tdakernel_stub_shared_memory.h"

#include <string.h> // for memcpy()

SharedMemoryStub::SharedMemoryStub(void* _hMemory, void* _hTDAPipedProcess)
{
  hMemory = _hMemory;
  hTDAPipedProcess = _hTDAPipedProcess;
}
void SharedMemoryStub::close()
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+5/*=strlen("close")*/;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (5 >> 8)&0xFF;
  buf[bufPos+1] = 5&0xFF;
  memcpy(&buf[bufPos+2], "close", 5);
  bufPos += 2 + 5;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return;
  }
  bufPos = 8;  // Reading nothing...
}
bool SharedMemoryStub::exists(const char* param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+6/*=strlen("exists")*/;
  size_t size1 = (param1==NULL)?0:strlen(param1);
  totalSize += (param1==NULL)?1/*NULL-indicator=false*/:1/*not-NULL indicator=true*/+2/*UTF-8 length*/+size1;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (6 >> 8)&0xFF;
  buf[bufPos+1] = 6&0xFF;
  memcpy(&buf[bufPos+2], "exists", 6);
  bufPos += 2 + 6;
  // Adding arguments...
  if (param1==NULL) {
    buf[bufPos] = (char)false; // indicating NULL
    bufPos++;
  }
  else {
    buf[bufPos] = (char)true; // indicating not-NULL
    buf[bufPos+1] = (size1 >> 8)&0xFF;
    buf[bufPos+2] = size1&0xFF;
    memcpy(&buf[bufPos+3], param1, size1);
    bufPos += 1 + 2 + size1;
  }

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
bool SharedMemoryStub::open(const char* param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+4/*=strlen("open")*/;
  size_t size1 = (param1==NULL)?0:strlen(param1);
  totalSize += (param1==NULL)?1/*NULL-indicator=false*/:1/*not-NULL indicator=true*/+2/*UTF-8 length*/+size1;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (4 >> 8)&0xFF;
  buf[bufPos+1] = 4&0xFF;
  memcpy(&buf[bufPos+2], "open", 4);
  bufPos += 2 + 4;
  // Adding arguments...
  if (param1==NULL) {
    buf[bufPos] = (char)false; // indicating NULL
    bufPos++;
  }
  else {
    buf[bufPos] = (char)true; // indicating not-NULL
    buf[bufPos+1] = (size1 >> 8)&0xFF;
    buf[bufPos+2] = size1&0xFF;
    memcpy(&buf[bufPos+3], param1, size1);
    bufPos += 1 + 2 + size1;
  }

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
bool SharedMemoryStub::startSave()
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+9/*=strlen("startSave")*/;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (9 >> 8)&0xFF;
  buf[bufPos+1] = 9&0xFF;
  memcpy(&buf[bufPos+2], "startSave", 9);
  bufPos += 2 + 9;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
bool SharedMemoryStub::cancelSave()
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+10/*=strlen("cancelSave")*/;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (10 >> 8)&0xFF;
  buf[bufPos+1] = 10&0xFF;
  memcpy(&buf[bufPos+2], "cancelSave", 10);
  bufPos += 2 + 10;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
bool SharedMemoryStub::finishSave()
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+10/*=strlen("finishSave")*/;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (10 >> 8)&0xFF;
  buf[bufPos+1] = 10&0xFF;
  memcpy(&buf[bufPos+2], "finishSave", 10);
  bufPos += 2 + 10;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
bool SharedMemoryStub::drop(const char* param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+4/*=strlen("drop")*/;
  size_t size1 = (param1==NULL)?0:strlen(param1);
  totalSize += (param1==NULL)?1/*NULL-indicator=false*/:1/*not-NULL indicator=true*/+2/*UTF-8 length*/+size1;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (4 >> 8)&0xFF;
  buf[bufPos+1] = 4&0xFF;
  memcpy(&buf[bufPos+2], "drop", 4);
  bufPos += 2 + 4;
  // Adding arguments...
  if (param1==NULL) {
    buf[bufPos] = (char)false; // indicating NULL
    bufPos++;
  }
  else {
    buf[bufPos] = (char)true; // indicating not-NULL
    buf[bufPos+1] = (size1 >> 8)&0xFF;
    buf[bufPos+2] = size1&0xFF;
    memcpy(&buf[bufPos+3], param1, size1);
    bufPos += 1 + 2 + size1;
  }

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
__int64 SharedMemoryStub::findClass(const char* param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+9/*=strlen("findClass")*/;
  size_t size1 = (param1==NULL)?0:strlen(param1);
  totalSize += (param1==NULL)?1/*NULL-indicator=false*/:1/*not-NULL indicator=true*/+2/*UTF-8 length*/+size1;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (9 >> 8)&0xFF;
  buf[bufPos+1] = 9&0xFF;
  memcpy(&buf[bufPos+2], "findClass", 9);
  bufPos += 2 + 9;
  // Adding arguments...
  if (param1==NULL) {
    buf[bufPos] = (char)false; // indicating NULL
    bufPos++;
  }
  else {
    buf[bufPos] = (char)true; // indicating not-NULL
    buf[bufPos+1] = (size1 >> 8)&0xFF;
    buf[bufPos+2] = size1&0xFF;
    memcpy(&buf[bufPos+3], param1, size1);
    bufPos += 1 + 2 + size1;
  }

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
const char* SharedMemoryStub::getClassName(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+12/*=strlen("getClassName")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return NULL;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (12 >> 8)&0xFF;
  buf[bufPos+1] = 12&0xFF;
  memcpy(&buf[bufPos+2], "getClassName", 12);
  bufPos += 2 + 12;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return NULL;
  }
  bufPos = 8;  bool b = false;
  unsigned char byteA = 0, byteB = 0;
  unsigned int len = 0;
  b = buf[bufPos++];
  if (b) { // not-NULL string
    byteA = buf[bufPos++];
    byteB = buf[bufPos++];
    len = (((unsigned int)byteA)<<8) | (unsigned int)byteB;
    char *s = new char[len+1];
    if (len>0)
      memcpy(s, &buf[bufPos], len);
    bufPos+=len;
    s[len] = '\0';
    const char *retVal = TDA_CreateReturnString(s);
    delete[] s;
    return retVal;
  }
  else {
    return NULL;
  }
}
__int64 SharedMemoryStub::createObject(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+12/*=strlen("createObject")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (12 >> 8)&0xFF;
  buf[bufPos+1] = 12&0xFF;
  memcpy(&buf[bufPos+2], "createObject", 12);
  bufPos += 2 + 12;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
__int64 SharedMemoryStub::createClass(const char* param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+11/*=strlen("createClass")*/;
  size_t size1 = (param1==NULL)?0:strlen(param1);
  totalSize += (param1==NULL)?1/*NULL-indicator=false*/:1/*not-NULL indicator=true*/+2/*UTF-8 length*/+size1;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (11 >> 8)&0xFF;
  buf[bufPos+1] = 11&0xFF;
  memcpy(&buf[bufPos+2], "createClass", 11);
  bufPos += 2 + 11;
  // Adding arguments...
  if (param1==NULL) {
    buf[bufPos] = (char)false; // indicating NULL
    bufPos++;
  }
  else {
    buf[bufPos] = (char)true; // indicating not-NULL
    buf[bufPos+1] = (size1 >> 8)&0xFF;
    buf[bufPos+2] = size1&0xFF;
    memcpy(&buf[bufPos+3], param1, size1);
    bufPos += 1 + 2 + size1;
  }

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
bool SharedMemoryStub::deleteClass(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+11/*=strlen("deleteClass")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (11 >> 8)&0xFF;
  buf[bufPos+1] = 11&0xFF;
  memcpy(&buf[bufPos+2], "deleteClass", 11);
  bufPos += 2 + 11;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
bool SharedMemoryStub::isClass(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+7/*=strlen("isClass")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (7 >> 8)&0xFF;
  buf[bufPos+1] = 7&0xFF;
  memcpy(&buf[bufPos+2], "isClass", 7);
  bufPos += 2 + 7;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
bool SharedMemoryStub::isDirectSubClass(__int64 param1, __int64 param2)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+16/*=strlen("isDirectSubClass")*/;
  totalSize += 8;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (16 >> 8)&0xFF;
  buf[bufPos+1] = 16&0xFF;
  memcpy(&buf[bufPos+2], "isDirectSubClass", 16);
  bufPos += 2 + 16;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;
  buf[bufPos] = (param2>>56)&0xFF;
  buf[bufPos+1] = (param2>>48)&0xFF;
  buf[bufPos+2] = (param2>>40)&0xFF;
  buf[bufPos+3] = (param2>>32)&0xFF;
  buf[bufPos+4] = (param2>>24)&0xFF;
  buf[bufPos+5] = (param2>>16)&0xFF;
  buf[bufPos+6] = (param2>>8)&0xFF;
  buf[bufPos+7] = param2&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
bool SharedMemoryStub::deleteObject(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+12/*=strlen("deleteObject")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (12 >> 8)&0xFF;
  buf[bufPos+1] = 12&0xFF;
  memcpy(&buf[bufPos+2], "deleteObject", 12);
  bufPos += 2 + 12;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
bool SharedMemoryStub::moveObject(__int64 param1, __int64 param2)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+10/*=strlen("moveObject")*/;
  totalSize += 8;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (10 >> 8)&0xFF;
  buf[bufPos+1] = 10&0xFF;
  memcpy(&buf[bufPos+2], "moveObject", 10);
  bufPos += 2 + 10;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;
  buf[bufPos] = (param2>>56)&0xFF;
  buf[bufPos+1] = (param2>>48)&0xFF;
  buf[bufPos+2] = (param2>>40)&0xFF;
  buf[bufPos+3] = (param2>>32)&0xFF;
  buf[bufPos+4] = (param2>>24)&0xFF;
  buf[bufPos+5] = (param2>>16)&0xFF;
  buf[bufPos+6] = (param2>>8)&0xFF;
  buf[bufPos+7] = param2&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
bool SharedMemoryStub::isTypeOf(__int64 param1, __int64 param2)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+8/*=strlen("isTypeOf")*/;
  totalSize += 8;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (8 >> 8)&0xFF;
  buf[bufPos+1] = 8&0xFF;
  memcpy(&buf[bufPos+2], "isTypeOf", 8);
  bufPos += 2 + 8;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;
  buf[bufPos] = (param2>>56)&0xFF;
  buf[bufPos+1] = (param2>>48)&0xFF;
  buf[bufPos+2] = (param2>>40)&0xFF;
  buf[bufPos+3] = (param2>>32)&0xFF;
  buf[bufPos+4] = (param2>>24)&0xFF;
  buf[bufPos+5] = (param2>>16)&0xFF;
  buf[bufPos+6] = (param2>>8)&0xFF;
  buf[bufPos+7] = param2&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
bool SharedMemoryStub::isKindOf(__int64 param1, __int64 param2)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+8/*=strlen("isKindOf")*/;
  totalSize += 8;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (8 >> 8)&0xFF;
  buf[bufPos+1] = 8&0xFF;
  memcpy(&buf[bufPos+2], "isKindOf", 8);
  bufPos += 2 + 8;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;
  buf[bufPos] = (param2>>56)&0xFF;
  buf[bufPos+1] = (param2>>48)&0xFF;
  buf[bufPos+2] = (param2>>40)&0xFF;
  buf[bufPos+3] = (param2>>32)&0xFF;
  buf[bufPos+4] = (param2>>24)&0xFF;
  buf[bufPos+5] = (param2>>16)&0xFF;
  buf[bufPos+6] = (param2>>8)&0xFF;
  buf[bufPos+7] = param2&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
__int64 SharedMemoryStub::createAttribute(__int64 param1, const char* param2, __int64 param3)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+15/*=strlen("createAttribute")*/;
  totalSize += 8;
  size_t size2 = (param2==NULL)?0:strlen(param2);
  totalSize += (param2==NULL)?1/*NULL-indicator=false*/:1/*not-NULL indicator=true*/+2/*UTF-8 length*/+size2;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (15 >> 8)&0xFF;
  buf[bufPos+1] = 15&0xFF;
  memcpy(&buf[bufPos+2], "createAttribute", 15);
  bufPos += 2 + 15;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;
  if (param2==NULL) {
    buf[bufPos] = (char)false; // indicating NULL
    bufPos++;
  }
  else {
    buf[bufPos] = (char)true; // indicating not-NULL
    buf[bufPos+1] = (size2 >> 8)&0xFF;
    buf[bufPos+2] = size2&0xFF;
    memcpy(&buf[bufPos+3], param2, size2);
    bufPos += 1 + 2 + size2;
  }
  buf[bufPos] = (param3>>56)&0xFF;
  buf[bufPos+1] = (param3>>48)&0xFF;
  buf[bufPos+2] = (param3>>40)&0xFF;
  buf[bufPos+3] = (param3>>32)&0xFF;
  buf[bufPos+4] = (param3>>24)&0xFF;
  buf[bufPos+5] = (param3>>16)&0xFF;
  buf[bufPos+6] = (param3>>8)&0xFF;
  buf[bufPos+7] = param3&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
bool SharedMemoryStub::isDerivedClass(__int64 param1, __int64 param2)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+14/*=strlen("isDerivedClass")*/;
  totalSize += 8;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (14 >> 8)&0xFF;
  buf[bufPos+1] = 14&0xFF;
  memcpy(&buf[bufPos+2], "isDerivedClass", 14);
  bufPos += 2 + 14;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;
  buf[bufPos] = (param2>>56)&0xFF;
  buf[bufPos+1] = (param2>>48)&0xFF;
  buf[bufPos+2] = (param2>>40)&0xFF;
  buf[bufPos+3] = (param2>>32)&0xFF;
  buf[bufPos+4] = (param2>>24)&0xFF;
  buf[bufPos+5] = (param2>>16)&0xFF;
  buf[bufPos+6] = (param2>>8)&0xFF;
  buf[bufPos+7] = param2&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
__int64 SharedMemoryStub::findAttribute(__int64 param1, const char* param2)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+13/*=strlen("findAttribute")*/;
  totalSize += 8;
  size_t size2 = (param2==NULL)?0:strlen(param2);
  totalSize += (param2==NULL)?1/*NULL-indicator=false*/:1/*not-NULL indicator=true*/+2/*UTF-8 length*/+size2;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (13 >> 8)&0xFF;
  buf[bufPos+1] = 13&0xFF;
  memcpy(&buf[bufPos+2], "findAttribute", 13);
  bufPos += 2 + 13;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;
  if (param2==NULL) {
    buf[bufPos] = (char)false; // indicating NULL
    bufPos++;
  }
  else {
    buf[bufPos] = (char)true; // indicating not-NULL
    buf[bufPos+1] = (size2 >> 8)&0xFF;
    buf[bufPos+2] = size2&0xFF;
    memcpy(&buf[bufPos+3], param2, size2);
    bufPos += 1 + 2 + size2;
  }

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
bool SharedMemoryStub::deleteAttribute(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+15/*=strlen("deleteAttribute")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (15 >> 8)&0xFF;
  buf[bufPos+1] = 15&0xFF;
  memcpy(&buf[bufPos+2], "deleteAttribute", 15);
  bufPos += 2 + 15;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
const char* SharedMemoryStub::getAttributeName(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+16/*=strlen("getAttributeName")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return NULL;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (16 >> 8)&0xFF;
  buf[bufPos+1] = 16&0xFF;
  memcpy(&buf[bufPos+2], "getAttributeName", 16);
  bufPos += 2 + 16;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return NULL;
  }
  bufPos = 8;  bool b = false;
  unsigned char byteA = 0, byteB = 0;
  unsigned int len = 0;
  b = buf[bufPos++];
  if (b) { // not-NULL string
    byteA = buf[bufPos++];
    byteB = buf[bufPos++];
    len = (((unsigned int)byteA)<<8) | (unsigned int)byteB;
    char *s = new char[len+1];
    if (len>0)
      memcpy(s, &buf[bufPos], len);
    bufPos+=len;
    s[len] = '\0';
    const char *retVal = TDA_CreateReturnString(s);
    delete[] s;
    return retVal;
  }
  else {
    return NULL;
  }
}
const char* SharedMemoryStub::getPrimitiveDataTypeName(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+24/*=strlen("getPrimitiveDataTypeName")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return NULL;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (24 >> 8)&0xFF;
  buf[bufPos+1] = 24&0xFF;
  memcpy(&buf[bufPos+2], "getPrimitiveDataTypeName", 24);
  bufPos += 2 + 24;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return NULL;
  }
  bufPos = 8;  bool b = false;
  unsigned char byteA = 0, byteB = 0;
  unsigned int len = 0;
  b = buf[bufPos++];
  if (b) { // not-NULL string
    byteA = buf[bufPos++];
    byteB = buf[bufPos++];
    len = (((unsigned int)byteA)<<8) | (unsigned int)byteB;
    char *s = new char[len+1];
    if (len>0)
      memcpy(s, &buf[bufPos], len);
    bufPos+=len;
    s[len] = '\0';
    const char *retVal = TDA_CreateReturnString(s);
    delete[] s;
    return retVal;
  }
  else {
    return NULL;
  }
}
__int64 SharedMemoryStub::findPrimitiveDataType(const char* param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+21/*=strlen("findPrimitiveDataType")*/;
  size_t size1 = (param1==NULL)?0:strlen(param1);
  totalSize += (param1==NULL)?1/*NULL-indicator=false*/:1/*not-NULL indicator=true*/+2/*UTF-8 length*/+size1;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (21 >> 8)&0xFF;
  buf[bufPos+1] = 21&0xFF;
  memcpy(&buf[bufPos+2], "findPrimitiveDataType", 21);
  bufPos += 2 + 21;
  // Adding arguments...
  if (param1==NULL) {
    buf[bufPos] = (char)false; // indicating NULL
    bufPos++;
  }
  else {
    buf[bufPos] = (char)true; // indicating not-NULL
    buf[bufPos+1] = (size1 >> 8)&0xFF;
    buf[bufPos+2] = size1&0xFF;
    memcpy(&buf[bufPos+3], param1, size1);
    bufPos += 1 + 2 + size1;
  }

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
bool SharedMemoryStub::isPrimitiveDataType(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+19/*=strlen("isPrimitiveDataType")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (19 >> 8)&0xFF;
  buf[bufPos+1] = 19&0xFF;
  memcpy(&buf[bufPos+2], "isPrimitiveDataType", 19);
  bufPos += 2 + 19;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
__int64 SharedMemoryStub::getIteratorForClasses()
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+21/*=strlen("getIteratorForClasses")*/;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (21 >> 8)&0xFF;
  buf[bufPos+1] = 21&0xFF;
  memcpy(&buf[bufPos+2], "getIteratorForClasses", 21);
  bufPos += 2 + 21;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
const char* SharedMemoryStub::getAttributeValue(__int64 param1, __int64 param2)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+17/*=strlen("getAttributeValue")*/;
  totalSize += 8;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return NULL;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (17 >> 8)&0xFF;
  buf[bufPos+1] = 17&0xFF;
  memcpy(&buf[bufPos+2], "getAttributeValue", 17);
  bufPos += 2 + 17;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;
  buf[bufPos] = (param2>>56)&0xFF;
  buf[bufPos+1] = (param2>>48)&0xFF;
  buf[bufPos+2] = (param2>>40)&0xFF;
  buf[bufPos+3] = (param2>>32)&0xFF;
  buf[bufPos+4] = (param2>>24)&0xFF;
  buf[bufPos+5] = (param2>>16)&0xFF;
  buf[bufPos+6] = (param2>>8)&0xFF;
  buf[bufPos+7] = param2&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return NULL;
  }
  bufPos = 8;  bool b = false;
  unsigned char byteA = 0, byteB = 0;
  unsigned int len = 0;
  b = buf[bufPos++];
  if (b) { // not-NULL string
    byteA = buf[bufPos++];
    byteB = buf[bufPos++];
    len = (((unsigned int)byteA)<<8) | (unsigned int)byteB;
    char *s = new char[len+1];
    if (len>0)
      memcpy(s, &buf[bufPos], len);
    bufPos+=len;
    s[len] = '\0';
    const char *retVal = TDA_CreateReturnString(s);
    delete[] s;
    return retVal;
  }
  else {
    return NULL;
  }
}
__int64 SharedMemoryStub::createAssociation(__int64 param1, __int64 param2, const char* param3, const char* param4, bool param5)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+17/*=strlen("createAssociation")*/;
  totalSize += 8;
  totalSize += 8;
  size_t size3 = (param3==NULL)?0:strlen(param3);
  totalSize += (param3==NULL)?1/*NULL-indicator=false*/:1/*not-NULL indicator=true*/+2/*UTF-8 length*/+size3;
  size_t size4 = (param4==NULL)?0:strlen(param4);
  totalSize += (param4==NULL)?1/*NULL-indicator=false*/:1/*not-NULL indicator=true*/+2/*UTF-8 length*/+size4;
  totalSize += 1;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (17 >> 8)&0xFF;
  buf[bufPos+1] = 17&0xFF;
  memcpy(&buf[bufPos+2], "createAssociation", 17);
  bufPos += 2 + 17;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;
  buf[bufPos] = (param2>>56)&0xFF;
  buf[bufPos+1] = (param2>>48)&0xFF;
  buf[bufPos+2] = (param2>>40)&0xFF;
  buf[bufPos+3] = (param2>>32)&0xFF;
  buf[bufPos+4] = (param2>>24)&0xFF;
  buf[bufPos+5] = (param2>>16)&0xFF;
  buf[bufPos+6] = (param2>>8)&0xFF;
  buf[bufPos+7] = param2&0xFF;
  bufPos += 8;
  if (param3==NULL) {
    buf[bufPos] = (char)false; // indicating NULL
    bufPos++;
  }
  else {
    buf[bufPos] = (char)true; // indicating not-NULL
    buf[bufPos+1] = (size3 >> 8)&0xFF;
    buf[bufPos+2] = size3&0xFF;
    memcpy(&buf[bufPos+3], param3, size3);
    bufPos += 1 + 2 + size3;
  }
  if (param4==NULL) {
    buf[bufPos] = (char)false; // indicating NULL
    bufPos++;
  }
  else {
    buf[bufPos] = (char)true; // indicating not-NULL
    buf[bufPos+1] = (size4 >> 8)&0xFF;
    buf[bufPos+2] = size4&0xFF;
    memcpy(&buf[bufPos+3], param4, size4);
    bufPos += 1 + 2 + size4;
  }
  buf[bufPos] = (char)param5;
  bufPos += 1;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
__int64 SharedMemoryStub::getIteratorForDirectSubClasses(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+30/*=strlen("getIteratorForDirectSubClasses")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (30 >> 8)&0xFF;
  buf[bufPos+1] = 30&0xFF;
  memcpy(&buf[bufPos+2], "getIteratorForDirectSubClasses", 30);
  bufPos += 2 + 30;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
__int64 SharedMemoryStub::getIteratorForAllClassObjects(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+29/*=strlen("getIteratorForAllClassObjects")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (29 >> 8)&0xFF;
  buf[bufPos+1] = 29&0xFF;
  memcpy(&buf[bufPos+2], "getIteratorForAllClassObjects", 29);
  bufPos += 2 + 29;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
__int64 SharedMemoryStub::getIteratorForDirectAttributes(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+30/*=strlen("getIteratorForDirectAttributes")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (30 >> 8)&0xFF;
  buf[bufPos+1] = 30&0xFF;
  memcpy(&buf[bufPos+2], "getIteratorForDirectAttributes", 30);
  bufPos += 2 + 30;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
__int64 SharedMemoryStub::getAttributeDomain(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+18/*=strlen("getAttributeDomain")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (18 >> 8)&0xFF;
  buf[bufPos+1] = 18&0xFF;
  memcpy(&buf[bufPos+2], "getAttributeDomain", 18);
  bufPos += 2 + 18;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
bool SharedMemoryStub::deleteGeneralization(__int64 param1, __int64 param2)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+20/*=strlen("deleteGeneralization")*/;
  totalSize += 8;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (20 >> 8)&0xFF;
  buf[bufPos+1] = 20&0xFF;
  memcpy(&buf[bufPos+2], "deleteGeneralization", 20);
  bufPos += 2 + 20;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;
  buf[bufPos] = (param2>>56)&0xFF;
  buf[bufPos+1] = (param2>>48)&0xFF;
  buf[bufPos+2] = (param2>>40)&0xFF;
  buf[bufPos+3] = (param2>>32)&0xFF;
  buf[bufPos+4] = (param2>>24)&0xFF;
  buf[bufPos+5] = (param2>>16)&0xFF;
  buf[bufPos+6] = (param2>>8)&0xFF;
  buf[bufPos+7] = param2&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
bool SharedMemoryStub::createGeneralization(__int64 param1, __int64 param2)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+20/*=strlen("createGeneralization")*/;
  totalSize += 8;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (20 >> 8)&0xFF;
  buf[bufPos+1] = 20&0xFF;
  memcpy(&buf[bufPos+2], "createGeneralization", 20);
  bufPos += 2 + 20;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;
  buf[bufPos] = (param2>>56)&0xFF;
  buf[bufPos+1] = (param2>>48)&0xFF;
  buf[bufPos+2] = (param2>>40)&0xFF;
  buf[bufPos+3] = (param2>>32)&0xFF;
  buf[bufPos+4] = (param2>>24)&0xFF;
  buf[bufPos+5] = (param2>>16)&0xFF;
  buf[bufPos+6] = (param2>>8)&0xFF;
  buf[bufPos+7] = param2&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
bool SharedMemoryStub::excludeObjectFromClass(__int64 param1, __int64 param2)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+22/*=strlen("excludeObjectFromClass")*/;
  totalSize += 8;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (22 >> 8)&0xFF;
  buf[bufPos+1] = 22&0xFF;
  memcpy(&buf[bufPos+2], "excludeObjectFromClass", 22);
  bufPos += 2 + 22;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;
  buf[bufPos] = (param2>>56)&0xFF;
  buf[bufPos+1] = (param2>>48)&0xFF;
  buf[bufPos+2] = (param2>>40)&0xFF;
  buf[bufPos+3] = (param2>>32)&0xFF;
  buf[bufPos+4] = (param2>>24)&0xFF;
  buf[bufPos+5] = (param2>>16)&0xFF;
  buf[bufPos+6] = (param2>>8)&0xFF;
  buf[bufPos+7] = param2&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
__int64 SharedMemoryStub::getIteratorForAllAttributes(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+27/*=strlen("getIteratorForAllAttributes")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (27 >> 8)&0xFF;
  buf[bufPos+1] = 27&0xFF;
  memcpy(&buf[bufPos+2], "getIteratorForAllAttributes", 27);
  bufPos += 2 + 27;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
bool SharedMemoryStub::includeObjectInClass(__int64 param1, __int64 param2)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+20/*=strlen("includeObjectInClass")*/;
  totalSize += 8;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (20 >> 8)&0xFF;
  buf[bufPos+1] = 20&0xFF;
  memcpy(&buf[bufPos+2], "includeObjectInClass", 20);
  bufPos += 2 + 20;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;
  buf[bufPos] = (param2>>56)&0xFF;
  buf[bufPos+1] = (param2>>48)&0xFF;
  buf[bufPos+2] = (param2>>40)&0xFF;
  buf[bufPos+3] = (param2>>32)&0xFF;
  buf[bufPos+4] = (param2>>24)&0xFF;
  buf[bufPos+5] = (param2>>16)&0xFF;
  buf[bufPos+6] = (param2>>8)&0xFF;
  buf[bufPos+7] = param2&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
__int64 SharedMemoryStub::getIteratorForDirectSuperClasses(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+32/*=strlen("getIteratorForDirectSuperClasses")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (32 >> 8)&0xFF;
  buf[bufPos+1] = 32&0xFF;
  memcpy(&buf[bufPos+2], "getIteratorForDirectSuperClasses", 32);
  bufPos += 2 + 32;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
__int64 SharedMemoryStub::getIteratorForDirectClassObjects(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+32/*=strlen("getIteratorForDirectClassObjects")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (32 >> 8)&0xFF;
  buf[bufPos+1] = 32&0xFF;
  memcpy(&buf[bufPos+2], "getIteratorForDirectClassObjects", 32);
  bufPos += 2 + 32;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
bool SharedMemoryStub::setAttributeValue(__int64 param1, __int64 param2, const char* param3)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+17/*=strlen("setAttributeValue")*/;
  totalSize += 8;
  totalSize += 8;
  size_t size3 = (param3==NULL)?0:strlen(param3);
  totalSize += (param3==NULL)?1/*NULL-indicator=false*/:1/*not-NULL indicator=true*/+2/*UTF-8 length*/+size3;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (17 >> 8)&0xFF;
  buf[bufPos+1] = 17&0xFF;
  memcpy(&buf[bufPos+2], "setAttributeValue", 17);
  bufPos += 2 + 17;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;
  buf[bufPos] = (param2>>56)&0xFF;
  buf[bufPos+1] = (param2>>48)&0xFF;
  buf[bufPos+2] = (param2>>40)&0xFF;
  buf[bufPos+3] = (param2>>32)&0xFF;
  buf[bufPos+4] = (param2>>24)&0xFF;
  buf[bufPos+5] = (param2>>16)&0xFF;
  buf[bufPos+6] = (param2>>8)&0xFF;
  buf[bufPos+7] = param2&0xFF;
  bufPos += 8;
  if (param3==NULL) {
    buf[bufPos] = (char)false; // indicating NULL
    bufPos++;
  }
  else {
    buf[bufPos] = (char)true; // indicating not-NULL
    buf[bufPos+1] = (size3 >> 8)&0xFF;
    buf[bufPos+2] = size3&0xFF;
    memcpy(&buf[bufPos+3], param3, size3);
    bufPos += 1 + 2 + size3;
  }

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
bool SharedMemoryStub::deleteAttributeValue(__int64 param1, __int64 param2)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+20/*=strlen("deleteAttributeValue")*/;
  totalSize += 8;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (20 >> 8)&0xFF;
  buf[bufPos+1] = 20&0xFF;
  memcpy(&buf[bufPos+2], "deleteAttributeValue", 20);
  bufPos += 2 + 20;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;
  buf[bufPos] = (param2>>56)&0xFF;
  buf[bufPos+1] = (param2>>48)&0xFF;
  buf[bufPos+2] = (param2>>40)&0xFF;
  buf[bufPos+3] = (param2>>32)&0xFF;
  buf[bufPos+4] = (param2>>24)&0xFF;
  buf[bufPos+5] = (param2>>16)&0xFF;
  buf[bufPos+6] = (param2>>8)&0xFF;
  buf[bufPos+7] = param2&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
__int64 SharedMemoryStub::getIteratorForDirectLinguisticInstances(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+39/*=strlen("getIteratorForDirectLinguisticInstances")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (39 >> 8)&0xFF;
  buf[bufPos+1] = 39&0xFF;
  memcpy(&buf[bufPos+2], "getIteratorForDirectLinguisticInstances", 39);
  bufPos += 2 + 39;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
__int64 SharedMemoryStub::getIteratorForDirectObjectClasses(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+33/*=strlen("getIteratorForDirectObjectClasses")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (33 >> 8)&0xFF;
  buf[bufPos+1] = 33&0xFF;
  memcpy(&buf[bufPos+2], "getIteratorForDirectObjectClasses", 33);
  bufPos += 2 + 33;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
__int64 SharedMemoryStub::getIteratorForObjectsByAttributeValue(__int64 param1, const char* param2)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+37/*=strlen("getIteratorForObjectsByAttributeValue")*/;
  totalSize += 8;
  size_t size2 = (param2==NULL)?0:strlen(param2);
  totalSize += (param2==NULL)?1/*NULL-indicator=false*/:1/*not-NULL indicator=true*/+2/*UTF-8 length*/+size2;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (37 >> 8)&0xFF;
  buf[bufPos+1] = 37&0xFF;
  memcpy(&buf[bufPos+2], "getIteratorForObjectsByAttributeValue", 37);
  bufPos += 2 + 37;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;
  if (param2==NULL) {
    buf[bufPos] = (char)false; // indicating NULL
    bufPos++;
  }
  else {
    buf[bufPos] = (char)true; // indicating not-NULL
    buf[bufPos+1] = (size2 >> 8)&0xFF;
    buf[bufPos+2] = size2&0xFF;
    memcpy(&buf[bufPos+3], param2, size2);
    bufPos += 1 + 2 + size2;
  }

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
__int64 SharedMemoryStub::getIteratorForAllOutgoingAssociationEnds(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+40/*=strlen("getIteratorForAllOutgoingAssociationEnds")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (40 >> 8)&0xFF;
  buf[bufPos+1] = 40&0xFF;
  memcpy(&buf[bufPos+2], "getIteratorForAllOutgoingAssociationEnds", 40);
  bufPos += 2 + 40;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
__int64 SharedMemoryStub::getIteratorForDirectIngoingAssociationEnds(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+42/*=strlen("getIteratorForDirectIngoingAssociationEnds")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (42 >> 8)&0xFF;
  buf[bufPos+1] = 42&0xFF;
  memcpy(&buf[bufPos+2], "getIteratorForDirectIngoingAssociationEnds", 42);
  bufPos += 2 + 42;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
__int64 SharedMemoryStub::getIteratorForAllLinguisticInstances(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+36/*=strlen("getIteratorForAllLinguisticInstances")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (36 >> 8)&0xFF;
  buf[bufPos+1] = 36&0xFF;
  memcpy(&buf[bufPos+2], "getIteratorForAllLinguisticInstances", 36);
  bufPos += 2 + 36;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
__int64 SharedMemoryStub::getIteratorForDirectOutgoingAssociationEnds(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+43/*=strlen("getIteratorForDirectOutgoingAssociationEnds")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (43 >> 8)&0xFF;
  buf[bufPos+1] = 43&0xFF;
  memcpy(&buf[bufPos+2], "getIteratorForDirectOutgoingAssociationEnds", 43);
  bufPos += 2 + 43;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
__int64 SharedMemoryStub::getIteratorForAllIngoingAssociationEnds(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+39/*=strlen("getIteratorForAllIngoingAssociationEnds")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (39 >> 8)&0xFF;
  buf[bufPos+1] = 39&0xFF;
  memcpy(&buf[bufPos+2], "getIteratorForAllIngoingAssociationEnds", 39);
  bufPos += 2 + 39;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
__int64 SharedMemoryStub::resolveIterator(__int64 param1, int param2)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+15/*=strlen("resolveIterator")*/;
  totalSize += 8;
  totalSize += 4;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (15 >> 8)&0xFF;
  buf[bufPos+1] = 15&0xFF;
  memcpy(&buf[bufPos+2], "resolveIterator", 15);
  bufPos += 2 + 15;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;
  buf[bufPos] = (param2>>24)&0xFF;
  buf[bufPos+1] = (param2>>16)&0xFF;
  buf[bufPos+2] = (param2>>8)&0xFF;
  buf[bufPos+3] = param2&0xFF;
  bufPos += 4;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
const char* SharedMemoryStub::getRoleName(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+11/*=strlen("getRoleName")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return NULL;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (11 >> 8)&0xFF;
  buf[bufPos+1] = 11&0xFF;
  memcpy(&buf[bufPos+2], "getRoleName", 11);
  bufPos += 2 + 11;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return NULL;
  }
  bufPos = 8;  bool b = false;
  unsigned char byteA = 0, byteB = 0;
  unsigned int len = 0;
  b = buf[bufPos++];
  if (b) { // not-NULL string
    byteA = buf[bufPos++];
    byteB = buf[bufPos++];
    len = (((unsigned int)byteA)<<8) | (unsigned int)byteB;
    char *s = new char[len+1];
    if (len>0)
      memcpy(s, &buf[bufPos], len);
    bufPos+=len;
    s[len] = '\0';
    const char *retVal = TDA_CreateReturnString(s);
    delete[] s;
    return retVal;
  }
  else {
    return NULL;
  }
}
bool SharedMemoryStub::deleteLink(__int64 param1, __int64 param2, __int64 param3)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+10/*=strlen("deleteLink")*/;
  totalSize += 8;
  totalSize += 8;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (10 >> 8)&0xFF;
  buf[bufPos+1] = 10&0xFF;
  memcpy(&buf[bufPos+2], "deleteLink", 10);
  bufPos += 2 + 10;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;
  buf[bufPos] = (param2>>56)&0xFF;
  buf[bufPos+1] = (param2>>48)&0xFF;
  buf[bufPos+2] = (param2>>40)&0xFF;
  buf[bufPos+3] = (param2>>32)&0xFF;
  buf[bufPos+4] = (param2>>24)&0xFF;
  buf[bufPos+5] = (param2>>16)&0xFF;
  buf[bufPos+6] = (param2>>8)&0xFF;
  buf[bufPos+7] = param2&0xFF;
  bufPos += 8;
  buf[bufPos] = (param3>>56)&0xFF;
  buf[bufPos+1] = (param3>>48)&0xFF;
  buf[bufPos+2] = (param3>>40)&0xFF;
  buf[bufPos+3] = (param3>>32)&0xFF;
  buf[bufPos+4] = (param3>>24)&0xFF;
  buf[bufPos+5] = (param3>>16)&0xFF;
  buf[bufPos+6] = (param3>>8)&0xFF;
  buf[bufPos+7] = param3&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
bool SharedMemoryStub::createLink(__int64 param1, __int64 param2, __int64 param3)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+10/*=strlen("createLink")*/;
  totalSize += 8;
  totalSize += 8;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (10 >> 8)&0xFF;
  buf[bufPos+1] = 10&0xFF;
  memcpy(&buf[bufPos+2], "createLink", 10);
  bufPos += 2 + 10;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;
  buf[bufPos] = (param2>>56)&0xFF;
  buf[bufPos+1] = (param2>>48)&0xFF;
  buf[bufPos+2] = (param2>>40)&0xFF;
  buf[bufPos+3] = (param2>>32)&0xFF;
  buf[bufPos+4] = (param2>>24)&0xFF;
  buf[bufPos+5] = (param2>>16)&0xFF;
  buf[bufPos+6] = (param2>>8)&0xFF;
  buf[bufPos+7] = param2&0xFF;
  bufPos += 8;
  buf[bufPos] = (param3>>56)&0xFF;
  buf[bufPos+1] = (param3>>48)&0xFF;
  buf[bufPos+2] = (param3>>40)&0xFF;
  buf[bufPos+3] = (param3>>32)&0xFF;
  buf[bufPos+4] = (param3>>24)&0xFF;
  buf[bufPos+5] = (param3>>16)&0xFF;
  buf[bufPos+6] = (param3>>8)&0xFF;
  buf[bufPos+7] = param3&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
bool SharedMemoryStub::isLinguistic(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+12/*=strlen("isLinguistic")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (12 >> 8)&0xFF;
  buf[bufPos+1] = 12&0xFF;
  memcpy(&buf[bufPos+2], "isLinguistic", 12);
  bufPos += 2 + 12;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
__int64 SharedMemoryStub::getAttributeType(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+16/*=strlen("getAttributeType")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (16 >> 8)&0xFF;
  buf[bufPos+1] = 16&0xFF;
  memcpy(&buf[bufPos+2], "getAttributeType", 16);
  bufPos += 2 + 16;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
__int64 SharedMemoryStub::getTargetClass(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+14/*=strlen("getTargetClass")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (14 >> 8)&0xFF;
  buf[bufPos+1] = 14&0xFF;
  memcpy(&buf[bufPos+2], "getTargetClass", 14);
  bufPos += 2 + 14;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
bool SharedMemoryStub::isAssociationEnd(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+16/*=strlen("isAssociationEnd")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (16 >> 8)&0xFF;
  buf[bufPos+1] = 16&0xFF;
  memcpy(&buf[bufPos+2], "isAssociationEnd", 16);
  bufPos += 2 + 16;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
void SharedMemoryStub::freeReference(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+13/*=strlen("freeReference")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (13 >> 8)&0xFF;
  buf[bufPos+1] = 13&0xFF;
  memcpy(&buf[bufPos+2], "freeReference", 13);
  bufPos += 2 + 13;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return;
  }
  bufPos = 8;  // Reading nothing...
}
bool SharedMemoryStub::isAttribute(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+11/*=strlen("isAttribute")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (11 >> 8)&0xFF;
  buf[bufPos+1] = 11&0xFF;
  memcpy(&buf[bufPos+2], "isAttribute", 11);
  bufPos += 2 + 11;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
__int64 SharedMemoryStub::getSourceClass(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+14/*=strlen("getSourceClass")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (14 >> 8)&0xFF;
  buf[bufPos+1] = 14&0xFF;
  memcpy(&buf[bufPos+2], "getSourceClass", 14);
  bufPos += 2 + 14;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
bool SharedMemoryStub::linkExists(__int64 param1, __int64 param2, __int64 param3)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+10/*=strlen("linkExists")*/;
  totalSize += 8;
  totalSize += 8;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (10 >> 8)&0xFF;
  buf[bufPos+1] = 10&0xFF;
  memcpy(&buf[bufPos+2], "linkExists", 10);
  bufPos += 2 + 10;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;
  buf[bufPos] = (param2>>56)&0xFF;
  buf[bufPos+1] = (param2>>48)&0xFF;
  buf[bufPos+2] = (param2>>40)&0xFF;
  buf[bufPos+3] = (param2>>32)&0xFF;
  buf[bufPos+4] = (param2>>24)&0xFF;
  buf[bufPos+5] = (param2>>16)&0xFF;
  buf[bufPos+6] = (param2>>8)&0xFF;
  buf[bufPos+7] = param2&0xFF;
  bufPos += 8;
  buf[bufPos] = (param3>>56)&0xFF;
  buf[bufPos+1] = (param3>>48)&0xFF;
  buf[bufPos+2] = (param3>>40)&0xFF;
  buf[bufPos+3] = (param3>>32)&0xFF;
  buf[bufPos+4] = (param3>>24)&0xFF;
  buf[bufPos+5] = (param3>>16)&0xFF;
  buf[bufPos+6] = (param3>>8)&0xFF;
  buf[bufPos+7] = param3&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
bool SharedMemoryStub::isComposition(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+13/*=strlen("isComposition")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (13 >> 8)&0xFF;
  buf[bufPos+1] = 13&0xFF;
  memcpy(&buf[bufPos+2], "isComposition", 13);
  bufPos += 2 + 13;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
void SharedMemoryStub::freeIterator(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+12/*=strlen("freeIterator")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (12 >> 8)&0xFF;
  buf[bufPos+1] = 12&0xFF;
  memcpy(&buf[bufPos+2], "freeIterator", 12);
  bufPos += 2 + 12;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return;
  }
  bufPos = 8;  // Reading nothing...
}
__int64 SharedMemoryStub::getLinguisticClassFor(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+21/*=strlen("getLinguisticClassFor")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (21 >> 8)&0xFF;
  buf[bufPos+1] = 21&0xFF;
  memcpy(&buf[bufPos+2], "getLinguisticClassFor", 21);
  bufPos += 2 + 21;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
bool SharedMemoryStub::deleteAssociation(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+17/*=strlen("deleteAssociation")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (17 >> 8)&0xFF;
  buf[bufPos+1] = 17&0xFF;
  memcpy(&buf[bufPos+2], "deleteAssociation", 17);
  bufPos += 2 + 17;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
bool SharedMemoryStub::createOrderedLink(__int64 param1, __int64 param2, __int64 param3, int param4)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+17/*=strlen("createOrderedLink")*/;
  totalSize += 8;
  totalSize += 8;
  totalSize += 8;
  totalSize += 4;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (17 >> 8)&0xFF;
  buf[bufPos+1] = 17&0xFF;
  memcpy(&buf[bufPos+2], "createOrderedLink", 17);
  bufPos += 2 + 17;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;
  buf[bufPos] = (param2>>56)&0xFF;
  buf[bufPos+1] = (param2>>48)&0xFF;
  buf[bufPos+2] = (param2>>40)&0xFF;
  buf[bufPos+3] = (param2>>32)&0xFF;
  buf[bufPos+4] = (param2>>24)&0xFF;
  buf[bufPos+5] = (param2>>16)&0xFF;
  buf[bufPos+6] = (param2>>8)&0xFF;
  buf[bufPos+7] = param2&0xFF;
  bufPos += 8;
  buf[bufPos] = (param3>>56)&0xFF;
  buf[bufPos+1] = (param3>>48)&0xFF;
  buf[bufPos+2] = (param3>>40)&0xFF;
  buf[bufPos+3] = (param3>>32)&0xFF;
  buf[bufPos+4] = (param3>>24)&0xFF;
  buf[bufPos+5] = (param3>>16)&0xFF;
  buf[bufPos+6] = (param3>>8)&0xFF;
  buf[bufPos+7] = param3&0xFF;
  bufPos += 8;
  buf[bufPos] = (param4>>24)&0xFF;
  buf[bufPos+1] = (param4>>16)&0xFF;
  buf[bufPos+2] = (param4>>8)&0xFF;
  buf[bufPos+3] = param4&0xFF;
  bufPos += 4;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
__int64 SharedMemoryStub::deserializeReference(const char* param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+20/*=strlen("deserializeReference")*/;
  size_t size1 = (param1==NULL)?0:strlen(param1);
  totalSize += (param1==NULL)?1/*NULL-indicator=false*/:1/*not-NULL indicator=true*/+2/*UTF-8 length*/+size1;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (20 >> 8)&0xFF;
  buf[bufPos+1] = 20&0xFF;
  memcpy(&buf[bufPos+2], "deserializeReference", 20);
  bufPos += 2 + 20;
  // Adding arguments...
  if (param1==NULL) {
    buf[bufPos] = (char)false; // indicating NULL
    bufPos++;
  }
  else {
    buf[bufPos] = (char)true; // indicating not-NULL
    buf[bufPos+1] = (size1 >> 8)&0xFF;
    buf[bufPos+2] = size1&0xFF;
    memcpy(&buf[bufPos+3], param1, size1);
    bufPos += 1 + 2 + size1;
  }

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
__int64 SharedMemoryStub::createDirectedAssociation(__int64 param1, __int64 param2, const char* param3, bool param4)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+25/*=strlen("createDirectedAssociation")*/;
  totalSize += 8;
  totalSize += 8;
  size_t size3 = (param3==NULL)?0:strlen(param3);
  totalSize += (param3==NULL)?1/*NULL-indicator=false*/:1/*not-NULL indicator=true*/+2/*UTF-8 length*/+size3;
  totalSize += 1;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (25 >> 8)&0xFF;
  buf[bufPos+1] = 25&0xFF;
  memcpy(&buf[bufPos+2], "createDirectedAssociation", 25);
  bufPos += 2 + 25;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;
  buf[bufPos] = (param2>>56)&0xFF;
  buf[bufPos+1] = (param2>>48)&0xFF;
  buf[bufPos+2] = (param2>>40)&0xFF;
  buf[bufPos+3] = (param2>>32)&0xFF;
  buf[bufPos+4] = (param2>>24)&0xFF;
  buf[bufPos+5] = (param2>>16)&0xFF;
  buf[bufPos+6] = (param2>>8)&0xFF;
  buf[bufPos+7] = param2&0xFF;
  bufPos += 8;
  if (param3==NULL) {
    buf[bufPos] = (char)false; // indicating NULL
    bufPos++;
  }
  else {
    buf[bufPos] = (char)true; // indicating not-NULL
    buf[bufPos+1] = (size3 >> 8)&0xFF;
    buf[bufPos+2] = size3&0xFF;
    memcpy(&buf[bufPos+3], param3, size3);
    bufPos += 1 + 2 + size3;
  }
  buf[bufPos] = (char)param4;
  bufPos += 1;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
bool SharedMemoryStub::isAdvancedAssociation(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+21/*=strlen("isAdvancedAssociation")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return false;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (21 >> 8)&0xFF;
  buf[bufPos+1] = 21&0xFF;
  memcpy(&buf[bufPos+2], "isAdvancedAssociation", 21);
  bufPos += 2 + 21;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return false;
  }
  bufPos = 8;  unsigned char byte = 0;
  byte = buf[bufPos++];
  return (byte!=0);
}
__int64 SharedMemoryStub::resolveIteratorFirst(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+20/*=strlen("resolveIteratorFirst")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (20 >> 8)&0xFF;
  buf[bufPos+1] = 20&0xFF;
  memcpy(&buf[bufPos+2], "resolveIteratorFirst", 20);
  bufPos += 2 + 20;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
const char* SharedMemoryStub::callSpecificOperation(const char* param1, const char* param2)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+21/*=strlen("callSpecificOperation")*/;
  size_t size1 = (param1==NULL)?0:strlen(param1);
  totalSize += (param1==NULL)?1/*NULL-indicator=false*/:1/*not-NULL indicator=true*/+2/*UTF-8 length*/+size1;
  size_t size2 = (param2==NULL)?0:strlen(param2);
  totalSize += (param2==NULL)?1/*NULL-indicator=false*/:1/*not-NULL indicator=true*/+2/*UTF-8 length*/+size2;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return NULL;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (21 >> 8)&0xFF;
  buf[bufPos+1] = 21&0xFF;
  memcpy(&buf[bufPos+2], "callSpecificOperation", 21);
  bufPos += 2 + 21;
  // Adding arguments...
  if (param1==NULL) {
    buf[bufPos] = (char)false; // indicating NULL
    bufPos++;
  }
  else {
    buf[bufPos] = (char)true; // indicating not-NULL
    buf[bufPos+1] = (size1 >> 8)&0xFF;
    buf[bufPos+2] = size1&0xFF;
    memcpy(&buf[bufPos+3], param1, size1);
    bufPos += 1 + 2 + size1;
  }
  if (param2==NULL) {
    buf[bufPos] = (char)false; // indicating NULL
    bufPos++;
  }
  else {
    buf[bufPos] = (char)true; // indicating not-NULL
    buf[bufPos+1] = (size2 >> 8)&0xFF;
    buf[bufPos+2] = size2&0xFF;
    memcpy(&buf[bufPos+3], param2, size2);
    bufPos += 1 + 2 + size2;
  }

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return NULL;
  }
  bufPos = 8;  bool b = false;
  unsigned char byteA = 0, byteB = 0;
  unsigned int len = 0;
  b = buf[bufPos++];
  if (b) { // not-NULL string
    byteA = buf[bufPos++];
    byteB = buf[bufPos++];
    len = (((unsigned int)byteA)<<8) | (unsigned int)byteB;
    char *s = new char[len+1];
    if (len>0)
      memcpy(s, &buf[bufPos], len);
    bufPos+=len;
    s[len] = '\0';
    const char *retVal = TDA_CreateReturnString(s);
    delete[] s;
    return retVal;
  }
  else {
    return NULL;
  }
}
__int64 SharedMemoryStub::getInverseAssociationEnd(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+24/*=strlen("getInverseAssociationEnd")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (24 >> 8)&0xFF;
  buf[bufPos+1] = 24&0xFF;
  memcpy(&buf[bufPos+2], "getInverseAssociationEnd", 24);
  bufPos += 2 + 24;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
int SharedMemoryStub::getLinkedObjectPosition(__int64 param1, __int64 param2, __int64 param3)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+23/*=strlen("getLinkedObjectPosition")*/;
  totalSize += 8;
  totalSize += 8;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (23 >> 8)&0xFF;
  buf[bufPos+1] = 23&0xFF;
  memcpy(&buf[bufPos+2], "getLinkedObjectPosition", 23);
  bufPos += 2 + 23;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;
  buf[bufPos] = (param2>>56)&0xFF;
  buf[bufPos+1] = (param2>>48)&0xFF;
  buf[bufPos+2] = (param2>>40)&0xFF;
  buf[bufPos+3] = (param2>>32)&0xFF;
  buf[bufPos+4] = (param2>>24)&0xFF;
  buf[bufPos+5] = (param2>>16)&0xFF;
  buf[bufPos+6] = (param2>>8)&0xFF;
  buf[bufPos+7] = param2&0xFF;
  bufPos += 8;
  buf[bufPos] = (param3>>56)&0xFF;
  buf[bufPos+1] = (param3>>48)&0xFF;
  buf[bufPos+2] = (param3>>40)&0xFF;
  buf[bufPos+3] = (param3>>32)&0xFF;
  buf[bufPos+4] = (param3>>24)&0xFF;
  buf[bufPos+5] = (param3>>16)&0xFF;
  buf[bufPos+6] = (param3>>8)&0xFF;
  buf[bufPos+7] = param3&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  int retVal = 0;
  unsigned char byte = 0;
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
int SharedMemoryStub::getIteratorLength(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+17/*=strlen("getIteratorLength")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (17 >> 8)&0xFF;
  buf[bufPos+1] = 17&0xFF;
  memcpy(&buf[bufPos+2], "getIteratorLength", 17);
  bufPos += 2 + 17;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  int retVal = 0;
  unsigned char byte = 0;
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
__int64 SharedMemoryStub::getIteratorForLinkedObjects(__int64 param1, __int64 param2)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+27/*=strlen("getIteratorForLinkedObjects")*/;
  totalSize += 8;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (27 >> 8)&0xFF;
  buf[bufPos+1] = 27&0xFF;
  memcpy(&buf[bufPos+2], "getIteratorForLinkedObjects", 27);
  bufPos += 2 + 27;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;
  buf[bufPos] = (param2>>56)&0xFF;
  buf[bufPos+1] = (param2>>48)&0xFF;
  buf[bufPos+2] = (param2>>40)&0xFF;
  buf[bufPos+3] = (param2>>32)&0xFF;
  buf[bufPos+4] = (param2>>24)&0xFF;
  buf[bufPos+5] = (param2>>16)&0xFF;
  buf[bufPos+6] = (param2>>8)&0xFF;
  buf[bufPos+7] = param2&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
__int64 SharedMemoryStub::createAdvancedAssociation(const char* param1, bool param2, bool param3)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+25/*=strlen("createAdvancedAssociation")*/;
  size_t size1 = (param1==NULL)?0:strlen(param1);
  totalSize += (param1==NULL)?1/*NULL-indicator=false*/:1/*not-NULL indicator=true*/+2/*UTF-8 length*/+size1;
  totalSize += 1;
  totalSize += 1;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (25 >> 8)&0xFF;
  buf[bufPos+1] = 25&0xFF;
  memcpy(&buf[bufPos+2], "createAdvancedAssociation", 25);
  bufPos += 2 + 25;
  // Adding arguments...
  if (param1==NULL) {
    buf[bufPos] = (char)false; // indicating NULL
    bufPos++;
  }
  else {
    buf[bufPos] = (char)true; // indicating not-NULL
    buf[bufPos+1] = (size1 >> 8)&0xFF;
    buf[bufPos+2] = size1&0xFF;
    memcpy(&buf[bufPos+3], param1, size1);
    bufPos += 1 + 2 + size1;
  }
  buf[bufPos] = (char)param2;
  bufPos += 1;
  buf[bufPos] = (char)param3;
  bufPos += 1;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
__int64 SharedMemoryStub::getIteratorForLinguisticClasses()
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+31/*=strlen("getIteratorForLinguisticClasses")*/;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (31 >> 8)&0xFF;
  buf[bufPos+1] = 31&0xFF;
  memcpy(&buf[bufPos+2], "getIteratorForLinguisticClasses", 31);
  bufPos += 2 + 31;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
__int64 SharedMemoryStub::findAssociationEnd(__int64 param1, const char* param2)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+18/*=strlen("findAssociationEnd")*/;
  totalSize += 8;
  size_t size2 = (param2==NULL)?0:strlen(param2);
  totalSize += (param2==NULL)?1/*NULL-indicator=false*/:1/*not-NULL indicator=true*/+2/*UTF-8 length*/+size2;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (18 >> 8)&0xFF;
  buf[bufPos+1] = 18&0xFF;
  memcpy(&buf[bufPos+2], "findAssociationEnd", 18);
  bufPos += 2 + 18;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;
  if (param2==NULL) {
    buf[bufPos] = (char)false; // indicating NULL
    bufPos++;
  }
  else {
    buf[bufPos] = (char)true; // indicating not-NULL
    buf[bufPos+1] = (size2 >> 8)&0xFF;
    buf[bufPos+2] = size2&0xFF;
    memcpy(&buf[bufPos+3], param2, size2);
    bufPos += 1 + 2 + size2;
  }

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
const char* SharedMemoryStub::serializeReference(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+18/*=strlen("serializeReference")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return NULL;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (18 >> 8)&0xFF;
  buf[bufPos+1] = 18&0xFF;
  memcpy(&buf[bufPos+2], "serializeReference", 18);
  bufPos += 2 + 18;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return NULL;
  }
  bufPos = 8;  bool b = false;
  unsigned char byteA = 0, byteB = 0;
  unsigned int len = 0;
  b = buf[bufPos++];
  if (b) { // not-NULL string
    byteA = buf[bufPos++];
    byteB = buf[bufPos++];
    len = (((unsigned int)byteA)<<8) | (unsigned int)byteB;
    char *s = new char[len+1];
    if (len>0)
      memcpy(s, &buf[bufPos], len);
    bufPos+=len;
    s[len] = '\0';
    const char *retVal = TDA_CreateReturnString(s);
    delete[] s;
    return retVal;
  }
  else {
    return NULL;
  }
}
__int64 SharedMemoryStub::resolveIteratorNext(__int64 param1)
{
  // counting the total size of data to be sent to the shared memory...
  unsigned int totalSize = 2/*UTF-8 length*/+19/*=strlen("resolveIteratorNext")*/;
  totalSize += 8;
  // Chechking for the buffer overflow...
  if (totalSize+8 > TDA_SHARED_MEMORY_SIZE)
    return 0;
  // Creating and filling the buffer...
  unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
  unsigned int bufPos = 8;
  // Adding the function name... (without NULL-indicator)
  buf[bufPos] = (19 >> 8)&0xFF;
  buf[bufPos+1] = 19&0xFF;
  memcpy(&buf[bufPos+2], "resolveIteratorNext", 19);
  bufPos += 2 + 19;
  // Adding arguments...
  buf[bufPos] = (param1>>56)&0xFF;
  buf[bufPos+1] = (param1>>48)&0xFF;
  buf[bufPos+2] = (param1>>40)&0xFF;
  buf[bufPos+3] = (param1>>32)&0xFF;
  buf[bufPos+4] = (param1>>24)&0xFF;
  buf[bufPos+5] = (param1>>16)&0xFF;
  buf[bufPos+6] = (param1>>8)&0xFF;
  buf[bufPos+7] = param1&0xFF;
  bufPos += 8;

  // Sending to the server...
  buf[4] = 0xFF & (totalSize >> 24);
  buf[5] = 0xFF & (totalSize >> 16);
  buf[6] = 0xFF & (totalSize >> 8);
  buf[7] = 0xFF & (totalSize);
  buf[3] = 1;
  // reading the return value...
  while (buf[3] != 0) {
    TDA_Sleep(0);
    if (TDA_IsPipedProcessTerminated(hTDAPipedProcess))
      return 0;
  }
  bufPos = 8;  __int64 retVal = 0;
  unsigned char byte = 0;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<56;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<48;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<40;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<32;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<24;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<16;
  byte = buf[bufPos++];
  retVal |= (__int64)byte<<8;
  byte = buf[bufPos++];
  retVal |= (__int64)byte;
  return retVal;
}
SharedMemoryStub::~SharedMemoryStub()
{
  if (hTDAPipedProcess != NULL)
    close();
  if (hMemory != NULL) {
    unsigned char *buf = TDA_GetSharedMemoryByteArray(hMemory);
    buf[3] = 2;
    for (int i =0; i<100; i++) {
      TDA_Sleep(1);
      if (buf[3] == 0)
        break;
    }

}
  if (hTDAPipedProcess != NULL) {
    TDA_ReleasePipedProcess(hTDAPipedProcess, true);
  }
  if (hMemory != NULL) {
    TDA_CloseSharedMemory(hMemory);
  }
}
