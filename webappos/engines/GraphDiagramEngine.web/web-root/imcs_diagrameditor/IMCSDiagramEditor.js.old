<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <!-- dojo with jquery support --->
<!--  <script src="/dojo/dojo.js" data-dojo-config="async:1, packages: [{ name: 'jquery-1.11.1.min', location: '/', main: 'jquery' }]"></script>
  <script>define.amd.jQuery = true;</script>
  <link rel="stylesheet" href="/themes/flat/flat.css" media="screen">-->

  <script type="text/javascript" src="/tda.js"></script>
  <script type="text/javascript" src="/jquery.js"></script>

<!--	<script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>-->
	<script src="/ajoox/GraphDiagramEngine-ajoo.js"></script>

  <script type="text/javascript" src="/imcs_layoutengine/imcs_layoutengine.js"></script>

</head>    
<body id="theBody">
  <div id="diagramDiv" onwheel="moveScrollWheel(event);" style="width:100%; height:100%; overflow:hidden; position:absolute; left:0;top:0;"></div>

  <div id="theMoveWrap"
       onwheel="moveZoomWheel(event);"
       onmousedown="mouseMoveStart(event);"
       onmouseup="mouseMoveEnd(event);"
       onmousemove="mouseMove(event);"
       oncontextmenu="window.toggleMoving();return false;" style="margin-left:40px; opacity:0.2; position:absolute; left:0; top:0; right:0; bottom:0; background-color:cccccc; display:none;"></div>


        <div id="scrollbar2"></div>
        <div id="scrollbar1"></div>
        <div id="theZoomMoveDiv" align=center>
          <span id="theZoomValue" align=center style="display:none;">100%</span>
          <div id="theZoomDiv" align=center>
            <div id="theZoomIn" onclick="dgr.zoomIn();showZoomValue();">&nbsp;+&nbsp;</div>
            <div id="theZoomOut" onclick="dgr.zoomOut();showZoomValue();">&nbsp;&ndash;&nbsp;</div>
          </div>
          <div id="theMiddleDiv"></div>
          <div id="theMoveDiv" onclick="toggleMoving();">&nbsp;&#x2725;&nbsp;</div>
        </div>
<script>

  var diagramMoving = false;

    window.updateScrollBars = function(visibleW, visibleH, totalW, totalH) {
console.log("UPDATE SB ",visibleW, visibleH, totalW, totalH);

      window.scrollbar2.outerHTML = 
        '<div id="scrollbar2">\
            <div class="scrollbar"><div class="track"><div class="thumb"><div class="end"></div></div></div></div>\
            <div id="scrollbar2viewport" class="viewport" style="width:'+(visibleW-15)+'px">\
              <div class="overview">\
                <div id="theHScrollerWidthDiv" style="width:'+(totalW+100)+'; height:1; left:0; position: absolute;"></div>\
              </div>\
            </div>\
        </div>';
      window.scrollbar1.outerHTML =
        '<div id="scrollbar1">\
            <div class="scrollbar"><div class="track"><div class="thumb"><div class="end"></div></div></div></div>\
            <div id="scrollbar1viewport" class="viewport" style="height:'+(visibleH-15)+'px">\
              <div class="overview">\
                <div id="theVScrollerHeightDiv" style="width:1; height:'+(totalH+60)+'; position: absolute;"></div>\
              </div>\
            </div>\
        </div>';

      $(document).ready(function() {
        $('#scrollbar1').tinyscrollbar({axis:'y'});
        $('#scrollbar2').tinyscrollbar({axis:'x'});

        window.scrollbar1move = function(ev)
        {
           var h = parseInt($("#scrollbar1").find(".scrollbar").css("height"));
           var th = parseInt($("#scrollbar1").find(".scrollbar").find(".track").find(".thumb").css("height"));
           var val = parseInt($("#scrollbar1").find(".scrollbar").find(".track").find(".thumb").css("top"));
//           var val = parseInt($("#scrollbar1viewport").find(".overview").css("top"));
           console.log(h, th, val);
           dgr.setRelativeY(val/(h-th));
           dgr.repaint();
        };

        $('#scrollbar1').bind("move", window.scrollbar1move);

        window.scrollbar2move = function(ev)
        {
           var w = parseInt($("#scrollbar2").find(".scrollbar").css("width"));
           var tw = parseInt($("#scrollbar2").find(".scrollbar").find(".track").find(".thumb").css("width"));
//           var val = parseInt($("#scrollbar2viewport").find(".overview").css("left"));
           var val = parseInt($("#scrollbar2").find(".scrollbar").find(".track").find(".thumb").css("left"));
           console.log(w, tw, val);
           dgr.setRelativeX(val/(w-tw));
           dgr.repaint();
        };
        $('#scrollbar2').bind("move", window.scrollbar2move);

        showHideScrollBars();
      });
    };

    window.toggleMoving = function() {
      window.diagramMoving = !window.diagramMoving;
      if (window.diagramMoving) {
        $("#ajoo_palette").css("opacity","0.5");
        $("#ajoo_palette").css("pointer-events","none");
        $(theMoveDiv).css("color", "blue");
        $(theMoveWrap).show();
        $(theMoveWrap).css("cursor", "move");
      }
      else {
        $("#ajoo_palette").css("opacity","1.0");
        $("#ajoo_palette").css("pointer-events","auto");
        $(theMoveDiv).css("color", "black");
        $(theMoveWrap).css("cursor", "auto");
        $(theMoveWrap).hide();
      }
    };

    window.moveScrollWheel = function(ev) {
      var val = parseInt($("#scrollbar1").find(".scrollbar").find(".track").find(".thumb").css("top"));
      if (ev.deltaY < 0) {
        val = val-10;
        if (val < 0)
          val = 0;
      }
      else
      if (ev.deltaY > 0) {
        val = val+10;
        var h = parseInt($("#scrollbar1").find(".scrollbar").css("height"));
        var th = parseInt($("#scrollbar1").find(".scrollbar").find(".track").find(".thumb").css("height"));
        var maxVal = h-th;
        if (val > maxVal)
          val = maxVal;
      }

      $("#scrollbar1").find(".scrollbar").find(".track").find(".thumb").css("top", val+"px");

      window.scrollbar1move();
    };

    window.moveZoomWheel = function(ev) {
      var x = ev.clientX - 40; // without palette
      var y = ev.clientY;

      if (ev.deltaY < 0) {
        dgr.zoomIn(x, y);showZoomValue();
      }
      else {
        dgr.zoomOut(x, y);showZoomValue();
      }
    };

    window.mouseMoveStart = function(ev) {
      window.diagramDragging = true;
      window.diagramDraggingLastX = ev.clientX-40;
      window.diagramDraggingLastY = ev.clientY;
    };

    window.mouseMoveEnd = function(ev) {
      window.diagramDragging = false;
    };

    window.mouseMove = function(ev) {
      if (ev.buttons==0) {
        window.diagramDragging = false;
      }
      if (window.diagramDragging) {
        var curX = ev.clientX-40;
        var curY = ev.clientY;
        var x = dgr.getX()*dgr.getZoomFactor();
        var y = dgr.getY()*dgr.getZoomFactor();
        x -= (window.diagramDraggingLastX-curX);
        y -= (window.diagramDraggingLastY-curY);
        dgr.setX(x/dgr.getZoomFactor());
        dgr.setY(y/dgr.getZoomFactor());
        dgr.repaint();
        window.diagramDraggingLastX = curX;
        window.diagramDraggingLastY = curY;
        showHideScrollBars();
      }
    };

    window.showZoomValue = function() {
      var d = new Date();
      window.zoomValueTime = d.getTime();
      theZoomValue.innerHTML = Math.round(dgr.getZoomFactor()*100)+"%";
      $(theZoomValue).show();
      setTimeout(function() {
        var d = new Date();
        var curTime = d.getTime();
        if (curTime - window.zoomValueTime >= 2000)
          $(theZoomValue).hide();
      },2000);
      showHideScrollBars();
    };

    window.showHideScrollBars = function() {
      if (dgr.getTotalWidth()*dgr.getZoomFactor()+100 < dgr.getVisibleWidth())
        $('#scrollbar2').find(".scrollbar").addClass("disable");
      else
        $('#scrollbar2').find(".scrollbar").removeClass("disable");

      if (dgr.getTotalHeight()*dgr.getZoomFactor()+60 < dgr.getVisibleHeight())
        $('#scrollbar1').find(".scrollbar").addClass("disable");
      else
        $('#scrollbar1').find(".scrollbar").removeClass("disable");

      // update scrollbar values...
      var h = parseInt($("#scrollbar1").find(".scrollbar").css("height"));
      var th = parseInt($("#scrollbar1").find(".scrollbar").find(".track").find(".thumb").css("height"));
      var val1 = (h-th)*dgr.getRelativeY();
      $("#scrollbar1").find(".scrollbar").find(".track").find(".thumb").css("top", val1+"px");

      var w = parseInt($("#scrollbar2").find(".scrollbar").css("width"));
      var tw = parseInt($("#scrollbar2").find(".scrollbar").find(".track").find(".thumb").css("width"));
      var val2 = (w-tw)*dgr.getRelativeX();
      $("#scrollbar2").find(".scrollbar").find(".track").find(".thumb").css("left", val2+"px");
    };

</script>
  <div id="thePleaseWaitDivWrap" style="z-index:9998; opacity:0.2; position:absolute; left:0; top:0; right:0; bottom:0; background-color:cccccc; display:none;"></div>
  <div id="thePleaseWaitDiv" style="z-index:9999; opacity:0.99; position:absolute; left:200; top:100; background-color:eeeeee; padding:20;  border-style:ridge; display:none;">Please, wait...</div>
  <script>
/*           $(document).ready(function(){
                $('#scrollbar1').tinyscrollbar();
            });*/

  function ShowPleaseWait(msg) {
	//if ((thePleaseWaitDivWrap.style.display == "block") && (thePleaseWaitDiv.innerHTML==msg))
		//return;
    thePleaseWaitDiv.innerHTML = msg;
    thePleaseWaitDivWrap.style.display = "block";
	if (!msg || (msg==""))
		thePleaseWaitDiv.style.display = "none";
	else
		thePleaseWaitDiv.style.display = "block";
    thePleaseWaitDiv.style.left = (thePleaseWaitDivWrap.clientWidth-thePleaseWaitDiv.clientWidth)/2;
    thePleaseWaitDiv.style.top = (thePleaseWaitDivWrap.clientHeight-thePleaseWaitDiv.clientHeight)/2;
	
	thePleaseWaitDiv.offsetHeight;
	thePleaseWaitDivWrap.offsetHeight;
	//$(window).trigger('resize');
  }
  function HidePleaseWait() {
    thePleaseWaitDivWrap.style.display = "none";
    thePleaseWaitDiv.style.display = "none";
  }
  </script>


<script>

function intToColor(num) {

    var b = num & 0xFF,
        g = (num & 0xFF00) >>> 8,
        r = (num & 0xFF0000) >>> 16;

  var sr = r.toString(16);
  while (sr.length<2)
   sr = "0"+sr;
  var sg = g.toString(16);
  while (sg.length<2)
   sg = "0"+sg;
  var sb = b.toString(16);
  while (sb.length<2)
   sb = "0"+sb;

  return "#" + sb+sg+sr;
}

function intToColor2(num) {

    var r = num & 0xFF,
        g = (num & 0xFF00) >>> 8,
        b = (num & 0xFF0000) >>> 16;

  var sr = r.toString(16);
  while (sr.length<2)
   sr = "0"+sr;
  var sg = g.toString(16);
  while (sg.length<2)
   sg = "0"+sg;
  var sb = b.toString(16);
  while (sb.length<2)
   sb = "0"+sb;

  return "#" + sb+sg+sr;
}

function intToRGBA(num) {
    num >>>= 0;
    var b = num & 0xFF,
        g = (num & 0xFF00) >>> 8,
        r = (num & 0xFF0000) >>> 16,
        a = ( (num & 0xFF000000) >>> 24 ) / 255 ;
    return "rgba(" + [r, g, b, a].join(",") + ")";
}


function getTextWidth(s, fontInfo) {
var canvas = document.createElement("canvas");
var ctx = canvas.getContext("2d");
ctx.font = fontInfo;//"20pt Arial";  // This can be set programmaticly from the element's font-style if desired
var textWidth = ctx.measureText(s).width;
return textWidth;
}


function getFontHeight(fontFamily, fontSize) {
  var body = document.getElementsByTagName("body")[0];
  var dummy = document.createElement("div");
  var dummyText = document.createTextNode("M");
  dummy.appendChild(dummyText);
  dummy.setAttribute("style", "font-family: " + fontFamily + "; font-size: " + fontSize + ";");
  body.appendChild(dummy);
  var result = dummy.offsetHeight;//dummy.offsetHeight;
//  result =parseInt(window.getComputedStyle(dummy).fontSize, 10);  --- fixed font-size (independent on scaling)

//result = Math.round(parseFloat($(dummy).css('font-size'))*1.5);

//  result = $(dummy).css('line-height');
  body.removeChild(dummy);
  return result;
};

///// GLOBAL VARIABLES /////

var gd; // GraphDiagram object in the repository
var dgr;  // diagram object AjooDiagramEditor
var elHash = {}; // element.reference -> element.hash (if hashes differ, the element must be re-added)
var elLastLocation = {}; // element.reference -> element last location string used in window.layout

var newBoxLocation = null;
var newLineLocation = null;

var lastRenderRequestTime = new Date();
var inRender = false;
var inUpdateCoos = false;

var activeExecuted = false;
var lastReadOnly = false;

///// HELPERS /////

function sortCompartments(arr)
{
  arr.sort(function(a,b) {
    return a.style.getOffsetY() - b.style.getOffsetY();
  });

  return arr;
}

function collectSubCompartments(arr) {
// clones...
  if (typeof arr == "undefined")
    return [];

  var retVal = [];
  for (var i=0; i<arr.length; i++) {
    retVal.push(arr[i]);
  }

// collecting sub-compartments
  var j=0;
  while (j<retVal.length) {

    if (retVal[j].isGroup == "true") {
      // adding children to the end of the list
      var children = retVal[j].subCompartment; 

      retVal.splice(j, 1); // remove the current element...

      // adding new elements...
      for (var k=0; k<children.length; k++)
        retVal.push(children[k]);
    }
    else {
      retVal[j] = TDA_CloneAttributes(retVal[j]);
      j++;
    }
  }

  return retVal;
}

function updateCollection(rDiagram, rElementsArr)
// rElementsArr is an array of elements, where at least the reference and
// the location(:String) attributes are specified
{
   console.log("in update collection "+rElementsArr.length);
   var arr = [];
   for (var i=0; i<rElementsArr.length; i++) {
     var el = tda.model[rElementsArr[i].reference];
/*     var className = el.getClassName();
     if (className=="Node") {
       el.setLocation(rElementsArr[i].location);
     }
     else
     if (className=="Edge") {
       el.setLocation(rElementsArr[i].location);
     }*/
     arr.push(el);
   }

   var gd = tda.model[rDiagram];

   var ptr = tda.model.CurrentDgrPointer.getFirstObject();
   ptr.setGraphDiagram(gd);

   var collArr = gd.getCollection();
   for (var i=0; i<collArr.length; i++) {
     collArr[i].setElement([]);
     collArr[i].delete();
   }

   var coll = new tda.model.Collection();
   coll.setElement(arr);
   gd.setCollection([coll]);
}


function updateLocations(rDiagram, rElementsArr)
// rElementsArr is an array of elements, where at least the reference and
// the location(:String) attributes are specified
{
   console.log("in update locations "+rElementsArr.length);
   for (var i=0; i<rElementsArr.length; i++) {
     var el = tda.model[rElementsArr[i].reference];
     var className = el.getClassName();
     if (className=="Node") {
       el.setLocation(rElementsArr[i].location);
     }
     else
     if (className=="Edge") {
       el.setLocation(rElementsArr[i].location);
     }
   }
}

function cloneElement(_el)
{
    // INITIAL CLONING
    var el = TDA_CloneAttributes(_el);	
    el.className = _el.getClassName();
	if (!el.className)
		return null;
    if (el.className == 'Edge') {
      el.start = [{reference:_el.start[0].reference, className:_el.start[0].getClassName()}];
      el.end = [{reference:_el.end[0].reference,className:_el.end[0].getClassName()}];
    }

    el.hash = "";

    // SPECIFIC CLONING...
    if (el.className == 'Node') {
      // converting style and location strings to objects (decoding AZ)...
      el.compartment = collectSubCompartments(_el.compartment);
      if (!el.style || (el.style=="#")) {
        var defaultStyle = _el.elemStyle;

        if (defaultStyle && (defaultStyle.length>0)) {
          var s = new NodeStyle();
          s.setFillColor( intToColor2(parseInt(defaultStyle[0].bkgColor)) ); // !!! not RGB, but BGR
          s.setShapeAZ( defaultStyle.shapeCode );
          s.setDashLength( defaultStyle.dashLength );
          s.setDashBreakLength( defaultStyle.breakLength );
          s.setLineColorAZ( defaultStyle.lineColor );
          s.setLineWidth( defaultStyle.lineWidth );
          el.style = s.toString();
        }
      }
      el.style = new NodeStyle(el.style);
      el.hash += el.style.toString();

      if (!el.location && newBoxLocation)  { // setting the location for the newly created box
        tda.model[el.reference].setLocation(newBoxLocation);
        el.location = newBoxLocation;
        newBoxLocation = null;
      }
      el.location = new NodeLocation(el.location);

      if (typeof el.compartment != 'undefined') {

        for (var j=0; j<el.compartment.length; j++) {
          if (!el.compartment[j].style || (el.compartment[j].style=="#")) {

            var defaultStyle = _el.compartment[j].compartStyle;
            if (defaultStyle && (defaultStyle.length>0)) {
              var s = new CompartmentStyle();
              s.setFontColorAZ(defaultStyle[0].fontColor);
              s.setFontFamily(defaultStyle[0].fontTypeFace);
              s.setFontWeightAZ(defaultStyle[0].fontStyle);
              s.setFontSize(parseInt(defaultStyle[0].fontSize)+2);
              s.setIsVisible(defaultStyle[0].isVisible);
              s.setAlignmentAZ(defaultStyle[0].alignment);
              s.setPlacementAZ(defaultStyle[0].adjustment);
              s.setLineWidth(defaultStyle[0].lineWidth);
              el.compartment[j].style = s.toString();
            }
          }

          // converting style string to an object (decoding AZ)...
          el.compartment[j].style = new CompartmentStyle(el.compartment[j].style);
          el.hash += "#"+el.compartment[j].reference+"#"+el.compartment[j].style.toString()+"#"+el.compartment[j].input+"#"+el.compartment[j].value;


        }

/*        el.compartment = el.compartment.sort(function(a,b) {
          return a.style.getOffsetY() - b.style.getOffsetY();
        });*/


      }


      if (el.location.getX()+el.location.getWidth() > maxX)
        maxX=el.location.getX()+el.location.getWidth();
      if (el.location.getY()+el.location.getHeight() > maxY)
        maxY=el.location.getY()+el.location.getHeight();

    }
    else
    if (el.className == 'Edge') {

      el.compartment = collectSubCompartments(_el.compartment);

      // converting style and location strings to objects (decoding AZ)...

      if (!el.location && newLineLocation)  { // setting the location for the newly created line
        tda.model[el.reference].setLocation(newLineLocation);
        el.location = newLineLocation;
        newLineLocation = null;

        window.newLineRef = el.reference;
      }


      if (!el.style || (el.style=="#")) {
        var defaultStyle = _el.elemStyle;

        if (defaultStyle && (defaultStyle.length>0)) {
          var s = new EdgeStyle();
          s.setFillColor( intToColor2(parseInt(defaultStyle[0].bkgColor)) ); // !!! not RGB, but BGR
          s.setShapeAZ( defaultStyle[0].shapeCode );
          s.setDashLength( defaultStyle[0].dashLength );
          s.setDashBreakLength( defaultStyle[0].breakLength );
          s.setLineColorAZ( defaultStyle[0].lineColor );
          s.setLineWidth( defaultStyle[0].lineWidth );

          
          s.setStartLabelStyleAZ(
            defaultStyle[0].startShapeCode,
            defaultStyle[0].startLineWidth,
            defaultStyle[0].startDashLength,
            defaultStyle[0].startBreakLength,
            defaultStyle[0].startBkgColor,
            defaultStyle[0].startLineColor);
            //args are (shapeCode, lineWidth, dashLength, breakLength, bkgColor, lineColor)

          s.setEndLabelStyleAZ(
            defaultStyle[0].endShapeCode,
            defaultStyle[0].endLineWidth,
            defaultStyle[0].endDashLength,
            defaultStyle[0].endBreakLength,
            defaultStyle[0].endBkgColor,
            defaultStyle[0].endLineColor);

          s.setMiddleLabelStyleAZ(
            defaultStyle[0].middleShapeCode,
            defaultStyle[0].middleLineWidth,
            defaultStyle[0].middleDashLength,
            defaultStyle[0].middleBreakLength,
            defaultStyle[0].middleBkgColor,
            defaultStyle[0].middleLineColor);

          el.style = s.toString();
        }
      }
      el.style = new EdgeStyle(el.style);
      el.hash += el.style.toString();

      if (newLineLocation) {
        tda.model[el.reference].setLocation(newLineLocation);
        el.location = newLineLocation;
        newLineLocation = null;
      }
      el.location = new EdgeLocation(el.location);

      var arr = el.location.getPointsXY();
      for (var j in arr) {
        if (arr[j].x > maxX)
          maxX = arr[j].x;
        if (arr[j].y > maxY)
          maxY = arr[j].y;
      };

      if (typeof el.compartment != 'undefined') {

        for (var j=0; j<el.compartment.length; j++) {
          // converting style string to an object (decoding AZ)...
          el.compartment[j].style = new CompartmentStyle(el.compartment[j].style);
          el.hash += "#"+el.compartment[j].reference+"#"+el.compartment[j].style.toString()+"#"+el.compartment[j].input+"#"+el.compartment[j].value;
        }

/*        el.compartment = el.compartment.sort(function(a,b) {
          return a.style.getOffsetY() - b.style.getOffsetY();
        });*/


      }

    }

	return el;
}

///// HANDLING EVENT OptionSelectedEvent /////
function handleOptionSelectedEvent(ev)
{
  console.log("handleOptionSelectedEvent "+ev.option[0].caption);
  var ee = tda.model.EnvironmentEngine.getFirstObject();
  var rocmd = new tda.model.RefreshOptionsCommand();
  rocmd.setEnvironmentEngine(ee);
  tda.model.submit(rocmd);
  
  if (ev.option[0].caption == "Semi-automatic") {
    gd.setLayoutMode(0);
    updateCoos(gd, true);
  }
  else
  if (ev.option[0].caption == "Manual")
    gd.setLayoutMode(1);
  else
  if (ev.option[0].caption == "Symmetrically") {
    gd.setLayoutAlgorithm(5);
    updateCoos(gd, false);
  }
  else
  if (ev.option[0].caption == "Hierarchically") {
    gd.setLayoutAlgorithm(2);
    updateCoos(gd, false);
  }
  else
  if (ev.option[0].caption == "Universally") {
    gd.setLayoutAlgorithm(3);
    updateCoos(gd, false);
  }  
}

///// RENDER FUNCTIONS /////
function now()
{
  var d = new Date();
  return d.getTime();
}

function isFork(el) {
        if (node.elemType && (node.elemType[0].caption=="HorizontalFork"))
          return true;

	if (node.elemType && (node.elemType[0].caption=="VerticalFork"))
	  return true;
  return false;
}

function adjustIfFork(el)
{
	var node = tda.model[el.reference];
	if (!node.elemType)
		return;
	
	if (el.location.getWidth()==0)
          el.location.setWidth(110);

        if (el.location.getHeight()==0)
          el.location.setHeight(49);

        if (node.elemType && (node.elemType[0].caption=="HorizontalFork"))
          el.location.setHeight(4);

	if (node.elemType && (node.elemType[0].caption=="VerticalFork"))
          el.location.setWidth(4);

        var s = el.location.toString();
        if (s!=node.location)
          node.setLocation(s);
	
	/*if (node.elemType[0].caption=="HorizontalFork") {
		el.location.setHeight(3);
		node.setLocation(el.location.toString());
	}
	else
	if (node.elemType[0].caption=="VerticalFork") {
		el.location.setWidth(3);
		node.setLocation(el.location.toString());
	}*/
}

function getLayoutSettingsForEdge(el, isIncremental)
{
		  var startNode = tda.model[el.start[0].reference];
		  var endNode = tda.model[el.end[0].reference];
		  var startSides = 15;
		  var endSides = 15;
		  if (startNode.elemType && (startNode.elemType[0].caption=="HorizontalFork") || (startNode.elemType[0].caption=="VerticalFork")) {
			if (startNode.elemType[0].caption=="HorizontalFork")
			  startSides = 5;
			else
			  startSides = 10;
		  }
		  if (endNode.elemType && (endNode.elemType[0].caption=="HorizontalFork") || (endNode.elemType[0].caption=="VerticalFork")) {
			if (endNode.elemType[0].caption=="HorizontalFork")
			  endSides = 5;
			else
			  endSides = 10;
		  }
		  
		if ((window.newLineRef!=el.reference)&&(isIncremental)) {
			// adjust points...
			var xyArr = el.location.getPointsXY();
			/*var L = xyArr.length-1;
			if (startNode.elemType && (startNode.elemType[0].caption=="HorizontalFork")) {
				var nl = new NodeLocation(startNode.location);
				if (xyArr[0].y > nl.getY()+nl.getHeight())
					xyArr[0].y = nl.getY()+nl.getHeight();
				if (xyArr[0].y < nl.getY())
					xyArr[0].y = nl.getY();
			}
			else
			if (endNode.elemType && (endNode.elemType[0].caption=="HorizontalFork")) {
				var nl = new NodeLocation(endNode.location);
				if (xyArr[L].y > nl.getY()+nl.getHeight())
					xyArr[L].y = nl.getY()+nl.getHeight();
				if (xyArr[L].y < nl.getY())
					xyArr[L].y = nl.getY();
			}*/
			//return {lineType:"ORTHOGONAL", startSides:startSides, endSides:endSides, points:el.location.getPointsXY()};
			return {lineType:"ORTHOGONAL", startSides:startSides, endSides:endSides, points:xyArr};
		}
		else
			return {lineType:"ORTHOGONAL", startSides:startSides, endSides:endSides};
}

function updateCoos(gd, isIncremental, modifiedArr, standbyshown)
// sets window.layout and window.clonedElements
{

  if (!window.layout)
    window.layout = new window.IMCSDiagramLayout("UNIVERSAL", true); // initial layout manager

  window.inUpdateCoos = true;
  if (!standbyshown) {
	//ShowPleaseWait("Updating the diagram...");
    setTimeout(function() { // waiting for the dojo "Layout" toolbar to disappear
	setTimeout(function() {
	setTimeout(function() {
	setTimeout(function() {
	setTimeout(function() {
		updateCoos(gd, isIncremental, modifiedArr, true);
	}, 0);
	}, 0);
	}, 0);
	}, 0);
	}, 0);
	return;
  }
  console.log("updateCoos()");

  tda.model.jsonsubmitAsync("layoutGraphDiagram", gd.reference+"", function(res) {
    console.log("jsonsubmitAsync RETURNED: ",res);
  });

  var time1=now();

  // preparing nodes and edges...
  window.clonedElements = [];
  var zeroCnt = 0;
  var nodeCnt = 0;
  var edgeCnt = 0;
  var forksCnt = 0;

  for (var i in gd.element) {
  	var el = cloneElement(gd.element[i]);
  	if (el) {
          clonedElements.push(el);
          if (el.className == 'Node') {
            nodeCnt++;
            if ((el.location.getWidth()==0) || (el.location.getHeight()==0))
              zeroCnt++;
            if (isFork)
              forksCnt++;
          }
          else
          if (el.className == 'Edge') {
            edgeCnt++;
          }
  	}
  }
  window.remaining = nodeCnt + edgeCnt;

  var time2=now();
  console.log("clone time: "+(time2-time1));
  if (zeroCnt > nodeCnt/2) {
    console.log("SWITCH FROM INCREMENTAL TO UNIVERSAL");
    isIncremental = false; // arrange from scratch; too many nodes with zero coos...
    if (forksCnt>0) {
       console.log("SWITCH TO HIERARCHICAL");
       gd.setLayoutAlgorithm(2);
    }

  }
  window.konvaTime = 0;
  window.layoutTime = 0;
  window.otherTime = 0;

  //test cache check...
  time1 = now();
  var changed=0;
  var changedN=0;
  for (var i=0; i<clonedElements.length; i++) {
    var el = clonedElements[i];
    if (el.className == 'Edge')
       changedN++;
    else
    if (el.className == 'Node')
       changedN++;
      if ((elHash[el.reference] != el.hash) || (elLastLocation[el.reference]!=tda.model[el.reference].location)) {
        changed++;
      }
  }
  var timeC = now();
  console.log("cache check: "+(timeC-time1), "changed: "+changed,changedN);

  var exceptionOccured = false;
  time1 = now();
try {
var time100=now();
  // adding new nodes to the diagram first...
  for (var i=0; i<clonedElements.length; i++) {
    var el = clonedElements[i];
//setTimeout(function(el) {
    if (el.className == 'Node') {
      window.remaining--;
      if ((elHash[el.reference] != el.hash) || (elLastLocation[el.reference]!=tda.model[el.reference].location)) {
//        console.log("elHash differs for node",el.reference,elHash[el.reference],el.hash);
        // this is a new node or an updated node
        var q = now();
		adjustIfFork(el);
	window.otherTime += now()-q;
	q = now();
        dgr.addNode(el); // addNode can deal with an updated node...
                         // addNode may update el.location width and height
        window.konvaTime += now()-q;
		if ((isIncremental) && (gd.layoutMode == 1))
			return;//continue;
	q = now();
		if (!layout.addBox(el.reference, el.location.getX(), el.location.getY(), el.location.getWidth(), el.location.getHeight())) {
			layout.resizeBox(el.reference, el.location.getWidth(), el.location.getHeight());
			layout.moveBox(el.reference, el.location.getX(), el.location.getY());
		}
	window.layoutTime += now()-q;
        elHash[el.reference] = el.hash;

      }
    }
	
	time2 = now();
	if (time2-time1>500) {
      ShowPleaseWait("Updating the diagram...");
//      console.log("pw1");
	}
//},0, el);
  }
var time200=now();
  // adding new edges to the diagram then...
/*
  for (var j=0; j<clonedElements.length; j++) {
    var el = clonedElements[j];
//setTimeout(function(el) {
    if (el.className == 'Edge') {
      window.remaining--;
      if ((elHash[el.reference] != el.hash) || (elLastLocation[el.reference]!=tda.model[el.reference].location)) {
//        console.log("elHash differs for edge",el.reference,elHash[el.reference],el.hash);
        // this is a new edge or an updated edge
        var q = now();
		var settings = getLayoutSettingsForEdge(el, isIncremental);
	window.otherTime += now()-q;
q = now();
	        dgr.addEdge(el);
window.konvaTime += now()-q;
		if ((isIncremental) && (gd.layoutMode == 1))
			return;//continue;
q = now();		
		if (!layout.addLine(el.reference, el.start[0].reference, el.end[0].reference, settings)) {
			layout.moveLine(el.reference, el.start[0].reference, el.end[0].reference, settings.points);
		}
window.layoutTime = now()-q;
        elHash[el.reference] = el.hash;
      }
    }
	time2 = now();
	if (time2-time1>500) {
      ShowPleaseWait("Updating the diagram...");
//      console.log("pw2");
	}
//},0, el);
  }
*/
var time300=now();

  for (var j=0; j<clonedElements.length; j++) {
    var el = clonedElements[j];
    if (el.className == 'Edge') {
      if ((elHash[el.reference] != el.hash) || (elLastLocation[el.reference]!=tda.model[el.reference].location)) {
	        dgr.addEdge(el);
      }
    }
  }
var time400=now();

  for (var j=0; j<clonedElements.length; j++) {
    var el = clonedElements[j];
    if (el.className == 'Edge') {
      window.remaining--;
      if ((elHash[el.reference] != el.hash) || (elLastLocation[el.reference]!=tda.model[el.reference].location)) {
		var settings = getLayoutSettingsForEdge(el, isIncremental);
		if ((isIncremental) && (gd.layoutMode == 1))
			return;//continue;
		if (!layout.addLine(el.reference, el.start[0].reference, el.end[0].reference, settings)) {
			layout.moveLine(el.reference, el.start[0].reference, el.end[0].reference, settings.points);
		}
        elHash[el.reference] = el.hash;
      }
    }
  }
var time500=now();

}catch(t) {
  console.log("exception during fast layout: ",t);
  exceptionOccured = true;
  window.remaining = 0;
}
  time2 = now();
  console.log("time100-200: "+(time200-time100));
  console.log("time200-300: "+(time300-time200));
  console.log("time300-400: "+(time400-time300));
  console.log("time400-500: "+(time500-time400));
  console.log("re-add time: "+(time2-time1));
  console.log("konva time: "+window.konvaTime);
  console.log("layout time: "+window.layoutTime, isIncremental);
  console.log("other time: "+window.otherTime);
  
var FFF = function() {
  // ne remaining, a delayedData

  if (dgr.delayedData) {
    console.log("not all added",dgr.delayedData.boxes.length, dgr.delayedData.lines.length);
    setTimeout(FFF, 200);
    return;
  }
  else
    console.log("delayedData = "+dgr.delayedData);

/*  if (window.remaining > 0) {
    console.log("0-timeout: remaining="+window.remaining);
    setTimeout(this, 100);
    return;
  }
  else
    console.log("remaining==0, all ok");*/

  if ((isIncremental) && (gd.layoutMode == 1)) {
    console.log("refresh and exit");
    dgr.refresh();
//    standby.hide();
    HidePleaseWait();
    return null; // do not perform incremental layout in manual mode
  }
  
  // removing old edges and nodes...
  var curNodesArr = dgr.getNodes();
  var curEdgesArr = dgr.getEdges();
  var repositorySet = {}; // current in the repository (may contain new)
  for (var i=0; i<gd.element.length; i++) {
    repositorySet[gd.element[i].reference]=true;
  }
  var removed = [];
  
  for (var i=0; i<curEdgesArr.length; i++) {
    if (!repositorySet[curEdgesArr[i].reference]) {
       removed.push({reference:curEdgesArr[i].reference});
       layout.removeLine(curEdgesArr[i].reference);
       delete elHash[curEdgesArr[i].reference];
    }
  }
  
  for (var i=0; i<curNodesArr.length; i++) {
    if (!repositorySet[curNodesArr[i].reference]) {
       removed.push({reference:curNodesArr[i].reference});
       layout.removeBox(curNodesArr[i].reference);
       delete elHash[curNodesArr[i].reference];
    }
  }
  dgr.removeElements(removed);

    HidePleaseWait();
	time2 = now();
	if (time2-time1>500)
      ShowPleaseWait("Updating the diagram (2)...");


  if (!isIncremental || exceptionOccured) {
    ShowPleaseWait("Updating the diagram (2)...");
  }

setTimeout(function(clonedElements, isIncremental, exceptionOccured) {

	///// LAYOUT CALCULATION >>>>
	var coos;
	try {  
	  if (!isIncremental || exceptionOccured) {
		delete window.layout;
	
		var layoutName = "UNIVERSAL";
		if (gd.layoutAlgorithm == 2) {
			//layoutName = "HORIZONTAL";
			layoutName = "INVERSE_VERTICAL";
		}
		else
		if (gd.layoutAlgorithm == 5)
			layoutName = "SYMMETRIC";
	
		console.log("Creating new layout "+layoutName);
		var time1 = now();
		window.layout = new IMCSDiagramLayout(layoutName, true);
	
		  // adding nodes to the layout first...
		  for (var i=0; i<clonedElements.length; i++) {
			var el = clonedElements[i];
			if (el.className == 'Node') {
			  layout.addBox(el.reference,
				el.location.getX(), el.location.getY(),
				el.location.getWidth(), el.location.getHeight());
			}
		  }
//	    if (!isIncremental) {
//	      console.log("IN-THE-MID1");
//	    coos = layout.arrangeIncrementally();
//	      console.log("IN-THE-MID2");
  //          }

// in-the-middle calculation...
/*	  if (isIncremental)
	    coos = layout.arrangeIncrementally();
	  else
	    coos = layout.arrangeFromScratch();*/
	
		  // adding edges to the layout then...
		  for (var j=0; j<clonedElements.length; j++) {
			var el = clonedElements[j];
			if (el.className == 'Edge') {
				el.location = new EdgeLocation(tda.model[el.reference].location); // update for forks...???
				var settings = getLayoutSettingsForEdge(el, isIncremental);
				layout.addLine(el.reference, el.start[0].reference, el.end[0].reference, settings);
			}
		  }
		var time2 = now();
	        console.log("created new in "+(time2-time1)+" ms");
	  } // if (!isIncremental)
	
	  var timeA = now();
	  if (isIncremental)
	    coos = layout.arrangeIncrementally();
	  else
	    coos = layout.arrangeFromScratch();
	  var timeB = now();
	  console.log("updateCoos - arranged in "+(timeB-timeA)+" ms; incrementally="+isIncremental);
	}
	catch(t) {
		var switchToManual = false;
		
		if (layout.fastAdd) {			
			console.log("switching to SLOW mode on exception ", t);
			console.log("Creating new slow layout "+layoutName);
/*		dgr.refresh();
  HidePleaseWait();
  window.inUpdateCoos = false;
return;	*/
			try {
				var time1 = now();
				window.layout = new IMCSDiagramLayout(layoutName, false);
var sss = '{"boxes":{';
var cnt=0;
			
				  // adding nodes to the layout first...
				  for (var i=0; i<clonedElements.length; i++) {
					var el = clonedElements[i];
					if (el.className == 'Node') {
					  layout.addBox(el.reference,
						el.location.getX(), el.location.getY(),
						el.location.getWidth(), el.location.getHeight());
					  cnt++;	
					  console.log("node "+i+"; "+cnt+" of "+clonedElements.length);	
					  sss+='"'+el.reference+'":{"x":'+el.location.getX()
                                                                 +',"y":'+el.location.getY()
                                                             +',"width":'+el.location.getWidth()
                                                            +',"height":'+el.location.getHeight()+'},';
					}
				  }
sss+='},"lines":{';
				  // adding edges to the layout then...
				  for (var j=0; j<clonedElements.length; j++) {
					var el = clonedElements[j];
					if (el.className == 'Edge') {
					  console.log("edge0 "+j+"; "+cnt+" of "+clonedElements.length);	
						el.location = new EdgeLocation(tda.model[el.reference].location); // update for forks...???
						var settings = getLayoutSettingsForEdge(el, isIncremental); //?
//delete settings.points;
					  console.log("edge1 "+el.reference+" "+j+"; "+cnt+" of "+clonedElements.length);	
						layout.addLine(el.reference, el.start[0].reference, el.end[0].reference, settings);
					  cnt++;	
					  console.log("edge2 "+j+"; "+cnt+" of "+clonedElements.length);	
					  sss+='"'+el.reference+'":{"from":"'+el.start[0].reference
                                                                  +'","to":"'+el.end[0].reference
                                                               +'","points":'+JSON.stringify(el.location.getPointsXY())+'},';
					}
				  }
sss+='}}';
				var time2 = now();
			    console.log("created new in "+(time2-time1)+" ms");
console.log(sss);
				  var timeA = now();
				  if (isIncremental)
				    coos = layout.arrangeIncrementally();
				  else
				    coos = layout.arrangeFromScratch();
				  var timeB = now();
				  console.log("updateCoos - arranged in "+(timeB-timeA)+" ms; incrementally="+isIncremental);
			}
			catch(tt) {
				switchToManual = true;
			}
		}
		else
			swithToManual = true;
		
		
		if (switchToManual) {		
		    console.log("switching to manual mode on exception ", t);
			gd.setLayoutMode(1);
			renderOptions(gd);
		    dgr.refresh();
		    HidePleaseWait();
		    return null; // do not perform incremental layout in manual mode
		}
	}
	///// <<<<< LAYOUT CALCULATION

console.log("LAYOUT!!!",coos);
var t1 = now();  
  // updating in the repository..
  for (var i=0; i<clonedElements.length; i++) {
    var el = clonedElements[i];
    if (el.className == 'Node') {
      el.location.setX(coos.boxes[el.reference].x);
      el.location.setY(coos.boxes[el.reference].y);
      el.location.setWidth(coos.boxes[el.reference].width);
      el.location.setHeight(coos.boxes[el.reference].height);

	  var locationStr = el.location.toString();
      tda.model[el.reference].setLocation(locationStr);
      dgr.updateNodeLocation(el.reference, coos.boxes[el.reference].x, coos.boxes[el.reference].y,
                             coos.boxes[el.reference].width, coos.boxes[el.reference].height);
							 
      elLastLocation[el.reference] = locationStr; // update elLastLocation
    }
    else
    if (el.className == 'Edge') {
      el.location.setPointsXY(coos.lines[el.reference]);
	  
	  var locationStr = el.location.toString();
      tda.model[el.reference].setLocation(locationStr);
      dgr.updateEdgeLocation(el.reference, el.location.getPointsArray());
	  elLastLocation[el.reference] = locationStr; // update elLastLocation
    }
  }
var t2 = now();  
console.log("updated repo in",t2-t1);

setTimeout(function() {
  console.log("dgr.refresh()");
  dgr.refresh(coos.width, coos.height); // the diagram width and height will be updated also
  HidePleaseWait();
  window.inUpdateCoos = false;
},200);
},0, clonedElements, isIncremental, exceptionOccured);
  
};
setTimeout(FFF,0);





}

function renderOptions(gd)
{
  var arr = gd.frame[0].getOption();
  for (var i=0; i<arr.length; i++)
    if (arr[i].id == "gdelayout") {
	  console.log("unlink gdelayout ribbon");
	  tda.model[arr[i].reference].delete();
	  i--; // continue with the same i
	}
  
  var opt = new tda.model.Option();
  opt.setCaption("Layout");
  opt.setLocation("RIBBON");
  opt.setFrame(gd.frame);
  opt.setId("gdelayout");

  var opt0 = new tda.model.Option();
  opt0.setCaption("<b>Layout mode:</b>");
  opt0.setLocation("RADIO");
  opt0.setFrame(gd.frame);
  opt.linkChild(opt0);

  var opt1 = new tda.model.Option();
  opt1.setCaption("Semi-automatic");
  opt1.setOnOptionSelectedEvent("engine:GraphDiagramEngine");
  opt1.setFrame(gd.frame);
  opt0.linkChild(opt1);
  var opt2 = new tda.model.Option();
  opt2.setCaption("Manual");
  opt2.setOnOptionSelectedEvent("engine:GraphDiagramEngine");
  opt2.setFrame(gd.frame);
  opt0.linkChild(opt2);

  if (gd.layoutMode == 0)
    opt1.setLocation("SELECTED"); // 0 = semi-automatic
  else
    opt2.setLocation("SELECTED"); // 1 = manual

  var optL = new tda.model.Option();
  optL.setLocation("LABEL");
  optL.setCaption("<b>Re-arrange:</b>");
  opt.linkChild(optL);

  var optU = new tda.model.Option();
  optU.setCaption("Universally");
  optU.setOnOptionSelectedEvent("engine:GraphDiagramEngine");
  optU.setFrame(gd.frame);
  opt.linkChild(optU);
  var optH = new tda.model.Option();
  optH.setCaption("Hierarchically");
  optH.setOnOptionSelectedEvent("engine:GraphDiagramEngine");
  optH.setFrame(gd.frame);
  opt.linkChild(optH);
  var optS = new tda.model.Option();
  optS.setCaption("Symmetrically");
  optS.setOnOptionSelectedEvent("engine:GraphDiagramEngine");
  optS.setFrame(gd.frame);
  opt.linkChild(optS);

  var ee = tda.model.EnvironmentEngine.getFirstObject();
  ee.linkOption(opt);
  var rocmd = new tda.model.RefreshOptionsCommand();
  rocmd.setEnvironmentEngine(ee);
  tda.model.submit(rocmd);
}

function renderFirst(gd, readOnly)
{
  window.gd = gd;
  console.log("rendering first "+gd);
  
  renderOptions(gd);

  window.inRender = true;

  maxX = 0, maxY=0;

  var rFrame = TDA_GetURLParameter("frameReference");
  gd.setFrame(tda.model[rFrame]);

  var settings = {};

  try {
    settings.backgroundColor = intToColor(parseInt(gd.bkgColor));
  }
  catch(t) {
    settings.backgroundColor = "#f0f8ff";
  }

  settings.diagramDiv = "diagramDiv";
  settings.readOnly = readOnly;
  lastReadOnly = readOnly;

  settings.paletteElements = gd.palette[0].paletteElement;

  if (gd.palette[0].paletteElement)
    maxY = gd.palette[0].paletteElement.length*32;



  if (!readOnly) {
  	settings.onNewBox = function (dgr, paletteElement, x, y, w, h) {
  		console.log("onNewBox ", paletteElement, x, y, w, h);

  		var location = new NodeLocation();
  		location.setX(x);
  		location.setY(y);
  		location.setWidth(w);
  		location.setHeight(h);
  		newBoxLocation = location.toString();

  		var event = new tda.model.NewBoxEvent();
  		event.setPaletteBox( tda.model[paletteElement.reference] );
  		tda.model.submit(event);
  		
  		// !!!!TODO: delete this box from dgr; it will be added during renderNext
  	};

  	settings.onNewLine = function(dgr, paletteElement, src, tgt, points) {
  		console.log("onNewLine", dgr, paletteElement, src, tgt, points);

  		var location = new EdgeLocation();
  		location.setPointsXY(points);
  		newLineLocation = location.toString();

  		var event = new tda.model.NewLineEvent();
  		event.setPaletteLine( tda.model[paletteElement.reference] );
  		event.setStart( tda.model[src.reference] );
  		event.setEnd( tda.model[tgt.reference] );
  		tda.model.submit(event);
  		// !!!!TODO: delete this line from dgr; it will be added during renderNext
  	};


  	settings.onElementsChange = function(dgr, rElementsArr, doLayout) {
  		// passes the array of boxes and lines with reference and location attributes according
  		// to TDA JSON syntax and AZ encoding;
  		// the array can be stored in the repository as is
  		console.log("onElementsChange", dgr, rElementsArr);
  		if (rElementsArr && (rElementsArr.length>0)) {
  			updateLocations(gd.reference, rElementsArr);
  			updateCollection(gd.reference, rElementsArr);
  			renderNext(gd);
  		}
  	};
    
  	settings.onDiagramClick = function(dgr) {
  		console.log("onDgrClick", dgr, []);
  		updateCollection(gd.reference, []);
  	};
  } // if not readOnly...

  settings.onSurfaceReady = function(dgr) {
    console.log("onSurfaceReady");
    // laying out...
    updateCoos(gd, true);
 
    setTimeout(function(){
      if (window.inUpdateCoos) {
console.log("onSurfaceReady wait");
        setTimeout(this, 100);
      }
      else {
        // selecting elements:
        var coll = gd.getCollection();
        if (coll && (coll.length>0) && (coll[0].element)) {
          var selected = coll[0].getElement();
          dgr.selectElements(selected); // can be passed w/o cloning
        }
        $(document).ready(function() {
          window.inRender = false;
        });
      }
    }, 100);
  }; // onSurfaceReady

//  settings.canvasWidth = screen.width;
//  settings.canvasHeight = screen.height;

  settings.onElementDoubleClick = function(reference) {
    console.log("settings.onElementDoubleClick");
    // updating current collection...
    var el = tda.model[reference];
    updateCollection(gd.reference, [el]);
    var event = new tda.model.L2ClickEvent();
    event.setElement(el);
    tda.model.submit(event);
  };

  dgr = new AjooDiagramEditor(settings);
}

function renderNext(gd)
{
  console.log("rendering next",gd);
  window.inRender = true;
  
  updateCoos(gd, true);

    setTimeout(function(){
      if (window.inUpdateCoos) {
console.log("rendernext wait");
        setTimeout(this, 100);
      }
      else {
/*        // selecting elements:
        if (gd.collection && (gd.collection.length>0) && (gd.collection[0].element)) {
          var selected = gd.collection[0].element;
          dgr.selectElements(selected); // can be passed w/o cloning
        }*/
        $(document).ready(function() {
          console.log("done rendering next");
          window.inRender = false;
        });
      }
    }, 100);
}


function renderGraphDiagram(_gd, _readOnly, _delayed) {

  if (!_delayed) {
    // delaying the request (perhaps, there are other requests upcoming)...
    lastRenderRequestTime = new Date();
    setTimeout( function() {
      var currTime = new Date();
      var diff = currTime.getTime() - lastRenderRequestTime.getTime();
      if ((diff>=600) && (typeof _gd != 'undefined')) {
        console.log("DIFF between renders: "+diff);
        // there was no other render request
        renderGraphDiagram(_gd, _readOnly, true);
      }
      else {
        // otherwise, another render request will be executed
        console.log("ignoring render request", diff);
      }
    }, 605);
    return;
  }

  if (window.inRender) {
    setTimeout( function() {
      renderGraphDiagram(_gd, _readOnly, true);
    }, 100);
    return;
  }

	if ((!dgr) || (_readOnly != lastReadOnly))
		renderFirst(_gd, _readOnly);
	else
		renderNext(_gd);
};

///// EXECUTING COMMANDS /////

function executeActiveDgrCmd(a) {
  console.log("command ActiveDgrCmd");
  activeExecuted = true;
  lastReadOnly = false;
  renderGraphDiagram(a.graphDiagram[0], false); // non-read-only

}
function executeActiveDgrViewCmd(a) {
  console.log("command ActiveDgrViewCmd");
  activeExecuted = true;
  lastReadOnly = true;
  renderGraphDiagram(a.graphDiagram[0], true); // read-only
}

function executeOkCmd(a) {
  console.log("command OkCmd");
  if (!activeExecuted) {
    console.log("OkCmd return");
    return;
  }
  if (a.element) {
    console.log(a.element.size, a.element);
  }
  renderGraphDiagram(a.graphDiagram[0], lastReadOnly);
}

function executeUpdateDgrCmd(a) {
  console.log("command UpdateDgrCmd");
//  if (!activeExecuted)
//    return;
  renderGraphDiagram(a.graphDiagram[0], lastReadOnly);
}

function executeActiveElementCmd(a) {
  console.log("command ActiveElementCmd");
  if (!activeExecuted)
    return;
  
  if (a.element && (a.element.length>0)) {
    var f = function() {
      if (dgr) {
        console.log("active el dgr ok");
        dgr.selectElements(a.element);
        updateCollection(a.graphDiagram[0].reference, a.element);
      }
      else {
        console.log("active el wait for dgr");
        setTimeout(this, 50);
      }
    };
    f();
  }
}

/*function executePT_RefreshCmd(a) {
  console.log("command PT#RefreshCmd");
  renderGraphDiagram(a.graphDiagram[0], lastReadOnly);
} */

</script>
</body>
</html>
